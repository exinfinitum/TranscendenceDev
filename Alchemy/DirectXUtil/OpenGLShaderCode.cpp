#include "PreComp.h"
#include "OpenGLShaderCode.h"

const std::string VGlowmapShader =
"#version 410 core\n"
"uniform mat4 rotationMatrix;\n"
"uniform vec2 aTexStartPoint;\n"
"uniform vec2 aTexQuadSizes;\n"
"\n"
"layout (location = 0) in vec3 aPos;\n"
"\n"
"layout (location = 0) out vec2 TexCoord;\n"
"//layout (location = 1) out vec2 TexStartPoint;\n"
"\n"
"void main()\n"
"{\n"
"	// Read coords span from 0 to 1, POSITIVE!!!!\n"
"    vec2 fixedTexSize = vec2(aTexQuadSizes[0], aTexQuadSizes[1]);\n"
"    vec2 texPositionOffset = vec2(fixedTexSize[0], fixedTexSize[1]) / 1.0;\n"
"    vec2 fixedTexPos = vec2(aTexStartPoint[0], aTexStartPoint[1]);\n"
"	vec2 quadPosFromZeroToOne = (vec2(aPos[0], aPos[1]) / 2) + vec2(0.5, 0.5);\n"
"	vec2 texPos2dRead = vec2(quadPosFromZeroToOne[0] * fixedTexSize[0], quadPosFromZeroToOne[1] * fixedTexSize[1]) + fixedTexPos;\n"
"\n"
"    // Write coords span from -1 to 1\n"
"	vec2 positionOffset = vec2(1.0, -1.0) * 1.0f;\n"
"	vec2 fixedCanvPos = vec2((0.0 * 2.0) - 1.0, -((0.0 * 2.0) - 1.0));\n"
"	fixedCanvPos = fixedCanvPos + positionOffset;\n"
"	vec2 texPos2dWrite = vec2(aPos[0] * 1.0, -aPos[1] * 1.0) + fixedCanvPos;\n"
"\n"
"    gl_Position = vec4(texPos2dWrite[0], texPos2dWrite[1], 0.1, 1.0);\n"
"	// Note that this inverts the image; since we do two passes and the second pass is over the entirety\n"
"	// of an image this should be OK as it inverts the image twice to gives us back a right side up image\n"
"	TexCoord = vec2(texPos2dRead[0], texPos2dRead[1]);\n"
"	//TexStartPoint = aTexStartPoint;\n"
"    //TexCoord = aTexCoord;\n"
"}\n";
const std::string VObjectTextureShader =
"#version 410 core\n"
"\n"
"layout (location = 0) in vec3 aPos;\n"
"layout (location = 1) in vec2 aTexPositions;\n"
"layout (location = 2) in vec2 aCanvasQuadSizes;\n"
"layout (location = 3) in vec2 aCanvasPositions;\n"
"layout (location = 4) in float aRotationInDegrees;\n"
"layout (location = 5) in vec2 aTexQuadSizes;\n"
"layout (location = 6) in vec2 aTexStartPoint;\n"
"layout (location = 7) in ivec2 aNumberOfFrames;\n"
"layout (location = 8) in float aAlphaStrength;\n"
"layout (location = 9) in vec4 aGlowColor;\n"
"layout (location = 10) in float aGlowNoise;\n"
"layout (location = 11) in vec4 aDecayPointInfo;\n"
"layout (location = 12) in ivec2 aRenderModes;\n"
"layout (location = 13) in int aGlowRadius;\n"
"layout (location = 14) in float aCanvasQuadAspectRatio; // ratio of width to height\n"
"layout (location = 15) in float aDepth;\n"
"\n"
"layout (location = 0) out vec2 texture_uv;\n"
"layout (location = 1) out vec2 texture_pos;\n"
"layout (location = 2) out vec2 texture_size;\n"
"layout (location = 3) out vec2 fragment_pos;\n"
"layout (location = 4) out vec2 texture_start_point;\n"
"layout (location = 5) flat out ivec2 num_frames;\n"
"layout (location = 6) out float alpha_strength;\n"
"layout (location = 7) out float depth;\n"
"layout (location = 8) out vec4 glow_color;\n"
"layout (location = 9) out float glow_noise;\n"
"layout (location = 10) out vec2 texture_bounds_min;\n"
"layout (location = 11) out vec2 texture_bounds_max;\n"
"layout (location = 12) flat out int render_category;\n"
"layout (location = 13) out vec2 texture_raw_pos;\n"
"layout (location = 14) flat out int glowRadius;\n"
"layout (location = 15) flat out int blendMode;\n"
"layout (location = 16) out vec2 decayPoint;\n"
"layout (location = 17) out float decayMaxRadius;\n"
"layout (location = 18) out float decayMinRadius;\n"
"layout (location = 19) out vec2 canvPosition;\n"
"\n"
"uniform vec2 aCanvasAdjustedDimensions;\n"
"\n"
"const int renderCategoryObject = 0;\n"
"const int renderCategoryText = 1;\n"
"const float PI = 3.14159;\n"
"\n"
"mat4 rotationMatrix2D(float rotation)\n"
"{\n"
"    // Generates a rotation matrix that rotates a vector counterclockwise in the XY plane by the specified rotation\n"
"    float sterm = sin(rotation);\n"
"    float cterm = cos(rotation);\n"
"    vec4 v1 = vec4(cterm, -sterm, 0, 0);\n"
"    vec4 v2 = vec4(sterm, cterm, 0, 0);\n"
"    vec4 v3 = vec4(0, 0, 1, 0);\n"
"    vec4 v4 = vec4(0, 0, 0, 1);\n"
"    return mat4(v1, v2, v3, v4);\n"
"}\n"
"\n"
"vec2 rotateVector2D(vec2 in_vec, float rotation_in_rad)\n"
"{\n"
"	mat4 rot_mat = rotationMatrix2D(rotation_in_rad);\n"
"	vec4 vec_to_rotate = vec4(in_vec[0], in_vec[1], 0, 1.0);\n"
"	vec4 rot_result = rot_mat * vec_to_rotate;\n"
"	return vec2(rot_result.x, rot_result.y);\n"
"}\n"
"\n"
"void main(void)\n"
"{\n"
"	// Fix positions and sizes\n"
"	vec2 fragmentPos = vec2(aPos[0] + 0.5f, aPos[1] + 0.5f);\n"
"	vec2 fixedSize = aCanvasQuadSizes * 2.0;\n"
"	vec2 fixedTexSize = aTexQuadSizes * 1.0;\n"
"	vec2 positionOffset = vec2(fixedSize[0], -fixedSize[1]) / 2.0;\n"
"	vec2 texPositionOffset = vec2(fixedTexSize[0], fixedTexSize[1]) / 2.0;\n"
"	vec2 proportionalCanvasPositions = aCanvasPositions / aCanvasAdjustedDimensions;\n"
"	vec2 fixedCanvPos = vec2((proportionalCanvasPositions[0] * 2.0) - 1.0, (proportionalCanvasPositions[1] * -2.0) + 1.0);\n"
"	vec2 fixedTexPos = vec2((aTexPositions[0] * 1.0), (aTexPositions[1] * 1.0));\n"
"	fixedCanvPos = fixedCanvPos + (positionOffset / aCanvasAdjustedDimensions);\n"
"	// Note that the order is Scale->Rotate->Scale->Translate. The first scaling is to size the quad in absolute terms properly,\n"
"	// the second scaling is to get the proper size relative to the canvas\n"
"	vec2 pos2d = (rotateVector2D(vec2(aPos[0], aPos[1]) * fixedSize, -(aRotationInDegrees * PI) / 180) / aCanvasAdjustedDimensions) + fixedCanvPos;\n"
"	vec2 texPos2d = vec2(aPos[0] * fixedTexSize[0], -aPos[1] * fixedTexSize[1]) + fixedTexPos + texPositionOffset;\n"
"	\n"
"    gl_Position = vec4(pos2d, aDepth, 1.0);\n"
"	depth = aDepth;\n"
"    texture_uv = texPos2d;\n"
"	texture_pos = aTexPositions;\n"
"	texture_size = fixedTexSize;\n"
"	fragment_pos = fragmentPos;\n"
"	alpha_strength = aAlphaStrength;\n"
"	glow_color = aGlowColor;\n"
"	glow_noise = aGlowNoise;\n"
"	texture_bounds_min = fixedTexPos;\n"
"	texture_bounds_max = fixedTexPos + texPositionOffset*2;\n"
"	render_category = aRenderModes[0];\n"
"	texture_raw_pos = vec2(aPos[0], aPos[1]);\n"
"	texture_start_point = aTexStartPoint;\n"
"	num_frames = aNumberOfFrames;\n"
"	blendMode = aRenderModes[1];\n"
"	glowRadius = aGlowRadius;\n"
"	decayPoint = vec2(aDecayPointInfo[0], aDecayPointInfo[1] / aCanvasQuadAspectRatio);\n"
"	decayMaxRadius = aDecayPointInfo[2];\n"
"	decayMinRadius = aDecayPointInfo[3];\n"
"	canvPosition = vec2(aPos[0], -aPos[1] / aCanvasQuadAspectRatio);\n"
"}\n";
const std::string VRayShader =
"#version 410 core\n"
"\n"
"// The shader used in RayRasterizer comprises the following:\n"
"// -Width specification. The RayRasterizer draws a line in an arbitrary direction, then extends it width-wise.\n"
"// What we can do is to transform a pixel back to a given rotational frame using the rotation, then using the distance\n"
"// from the axis to get the width. Note, the C code uses a WidthCount and LengthCount to divide the ray into cells.\n"
"// We can use modulos and similar methods to determine which cell our pixel is in.\n"
"// -Length specification. There is an array of lengths in the C code; we can just pass the specified one directly into\n"
"// our VBO. It is specified as a number of length "cells" in the C code, but this is what is meant (?)\n"
"// -Start and end points. Since we're using OpenGL we can just generate the horizontal ray, and rotate the quad ourselves at\n"
"// the end. Simpler! No need to transform pixels back on a per-pixel basis; we handle this in vertex shader!\n"
"\n"
"// Vertex shader should handle only the sizing and rotation aspects. All the magic happens in fragment shader.\n"
"// Note, it seems that numLengthCells is just the length of the ray in pixels...\n"
"\n"
"layout (location = 0) in vec4 aPos;\n"
"layout (location = 1) in vec4 aSizeAndPosition;\n"
"layout (location = 2) in float aRotation;\n"
"layout (location = 3) in ivec4 aShapes;\n"
"layout (location = 4) in ivec4 aStyles;\n"
"layout (location = 5) in vec4 aFloatParams;\n"
"layout (location = 6) in vec3 aPrimaryColor;\n"
"layout (location = 7) in vec3 aSecondaryColor;\n"
"layout (location = 8) in float aSeed;\n"
"layout (location = 9) in int aEffectType;\n"
"layout (location = 10) in int aBlendMode;\n"
"layout (location = 11) in float aDepth;\n"
"\n"
"uniform vec2 aCanvasAdjustedDimensions;\n"
"\n"
"layout (location = 0) out vec2 quadPos;\n"
"layout (location = 1) flat out int rayReshape;\n"
"layout (location = 2) flat out int rayWidthAdjType;\n"
"layout (location = 3) flat out int rayOpacity;\n"
"layout (location = 4) flat out int rayGrainyTexture;\n"
"layout (location = 5) out float depth;\n"
"layout (location = 6) out float intensity;\n"
"layout (location = 7) out vec3 primaryColor;\n"
"layout (location = 8) out vec3 secondaryColor;\n"
"layout (location = 9) out float waveCyclePos;\n"
"layout (location = 10) flat out int rayColorTypes;\n"
"layout (location = 11) out float opacityAdj;\n"
"layout (location = 12) flat out int effectType;\n"
"layout (location = 13) out float seed;\n"
"layout (location = 14) out vec2 quadSize;\n"
"layout (location = 15) flat out int orbAnimation; //\n"
"layout (location = 16) flat out int orbStyle; //\n"
"layout (location = 17) flat out int orbDistortion;\n"
"layout (location = 18) flat out int orbDetail;\n"
"layout (location = 19) out float orbSecondaryOpacity;\n"
"layout (location = 20) flat out int orbLifetime;\n"
"layout (location = 21) flat out int orbCurrFrame;\n"
"layout (location = 22) flat out int blendMode;\n"
"layout (location = 23) flat out float rotation;\n"
"layout (location = 24) flat out int particleDestiny;\n"
"layout (location = 25) flat out float particleMinRadius;\n"
"\n"
"// This should match enum effectType in opengl.h.\n"
"// Note that flares are under the ray category.\n"
"\n"
"int effectTypeRay = 0;\n"
"int effectTypeLightning = 1;\n"
"int effectTypeOrb = 2;\n"
"int effectTypeFlare = 3;\n"
"int effectTypeParticle = 4;\n"
"\n"
"mat4 rotationMatrix2D(float rotation)\n"
"{\n"
"    // Generates a rotation matrix that rotates a vector counterclockwise in the XY plane by the specified rotation\n"
"    float sterm = sin(rotation);\n"
"    float cterm = cos(rotation);\n"
"    vec4 v1 = vec4(cterm, -sterm, 0, 0);\n"
"    vec4 v2 = vec4(sterm, cterm, 0, 0);\n"
"    vec4 v3 = vec4(0, 0, 1, 0);\n"
"    vec4 v4 = vec4(0, 0, 0, 1);\n"
"    return mat4(v1, v2, v3, v4);\n"
"}\n"
"\n"
"mat4 scalingMatrix2D(float scaleX, float scaleY)\n"
"{\n"
"    // Generates a rotation matrix that rotates a vector counterclockwise in the XY plane by the specified rotation\n"
"    vec4 v1 = vec4(scaleX, 0, 0, 0);\n"
"    vec4 v2 = vec4(0, scaleY, 0, 0);\n"
"    vec4 v3 = vec4(0, 0, 1, 0);\n"
"    vec4 v4 = vec4(0, 0, 0, 1);\n"
"    return mat4(v1, v2, v3, v4);\n"
"}\n"
"\n"
"mat4 translationMatrix2D(float transX, float transY)\n"
"{\n"
"    // Generates a rotation matrix that rotates a vector counterclockwise in the XY plane by the specified rotation\n"
"    vec4 v1 = vec4(1, 0, 0, transX);\n"
"    vec4 v2 = vec4(0, 1, 0, transY);\n"
"    vec4 v3 = vec4(0, 0, 1, 0);\n"
"    vec4 v4 = vec4(0, 0, 0, 1);\n"
"    return mat4(v1, v2, v3, v4);\n"
"}\n"
"\n"
"void main(void)\n"
"{\n"
"    vec2 aSize = vec2(aSizeAndPosition[0], aSizeAndPosition[1]) * ((2.0*float(aEffectType == effectTypeOrb)) + (float(aEffectType != effectTypeOrb)));\n"
"    vec2 aPosOnCanvas = (vec2(aSizeAndPosition[2], aSizeAndPosition[3]) - vec2(0.5, 0.5)) * 2.0;\n"
"\n"
"	// Note that the order is Scale->Rotate->Scale->Translate. The first scaling is to size the quad in absolute terms properly,\n"
"	// the second scaling is to get the proper size relative to the canvas\n"
"	vec4 final_pos = aPos * scalingMatrix2D(aSize[0], aSize[1]) * rotationMatrix2D(aRotation) * scalingMatrix2D(1.0 / aCanvasAdjustedDimensions[0], 1.0 / aCanvasAdjustedDimensions[1]) * translationMatrix2D(aPosOnCanvas[0], -aPosOnCanvas[1]);\n"
"\n"
"	quadPos = vec2(aPos[0], aPos[1]) * 2.0;\n"
"\n"
"    // For rays and lightning, aShapes, aStyles and aFloatParams are, in order:\n"
"	// aShapes: widthAdjType, reshape, blank, blank\n"
"	// aStyles: colorTypes, opacity, graintyTexture, blank\n"
"	// aFloatParams: intensity, waveCyclePos, opacityAdj, blank\n"
"\n"
"	// For orbs, aShapes, aStyles and aFloatParams are, in order:\n"
"	// aShapes: orbLifetime, orbCurrFrame, orbDistortion, orbDetail\n"
"	// aStyles: orbStyle, orbAnimation, opacity, blank\n"
"	// aFloatParams: intensity, orbSecondaryOpacity, opacityAdj, blank\n"
"\n"
"	// For particles, aShapes, aStyles and aFloatParams are, in order:\n"
"	// aShapes: orbLifetime, orbCurrFrame, orbDistortion, blank\n"
"	// aStyles: orbStyle, particleDestiny, opacity, blank\n"
"	// aFloatParams: minRadius, maxRadius, opacityAdj, blank\n"
"	// Note, rotation is already supplied separately as aRotation, and orbRadius is reused as maxRadius, along with orbStyle as style\n"
"	// and orbLifetime/orbCurrFrame as lifetime/currFrame respectively.\n"
"	// orbRadius, particleMinRadius, primaryColor, secondaryColor, opacityAdj, lifetime, currFrame, rotation, style, particleDestiny\n"
"\n"
"\n"
"    rayWidthAdjType = aShapes[0];\n"
"    rayReshape = aShapes[1];\n"
"    rayColorTypes = aStyles[0];\n"
"    rayOpacity = aStyles[1];\n"
"    rayGrainyTexture = aStyles[2];\n"
"    particleDestiny = aStyles[1];\n"
"    particleMinRadius = aFloatParams[0];\n"
"    orbLifetime = aShapes[0];\n"
"    orbCurrFrame = aShapes[1];\n"
"    orbDistortion = aShapes[2];\n"
"    orbDetail = aShapes[3];\n"
"    orbStyle = aStyles[0];\n"
"    orbAnimation = aStyles[1];\n"
"    orbSecondaryOpacity = aFloatParams[1];\n"
"\n"
"    depth = aDepth;\n"
"    rotation = aRotation;\n"
"    intensity = aFloatParams[0];\n"
"    opacityAdj = aFloatParams[2];\n"
"    waveCyclePos = aFloatParams[3];\n"
"    primaryColor = aPrimaryColor;\n"
"    secondaryColor = aSecondaryColor;\n"
"    quadSize = aSize;\n"
"    gl_Position = final_pos;\n"
"	seed = aSeed;\n"
"	effectType = aEffectType;\n"
"	blendMode = aBlendMode;\n"
"}\n";
const std::string VOrbShader =
"#version 410 core\n"
"\n"
"// The shader used in RayRasterizer comprises the following:\n"
"// -Width specification. The RayRasterizer draws a line in an arbitrary direction, then extends it width-wise.\n"
"// What we can do is to transform a pixel back to a given rotational frame using the rotation, then using the distance\n"
"// from the axis to get the width. Note, the C code uses a WidthCount and LengthCount to divide the ray into cells.\n"
"// We can use modulos and similar methods to determine which cell our pixel is in.\n"
"// -Length specification. There is an array of lengths in the C code; we can just pass the specified one directly into\n"
"// our VBO. It is specified as a number of length "cells" in the C code, but this is what is meant (?)\n"
"// -Start and end points. Since we're using OpenGL we can just generate the horizontal ray, and rotate the quad ourselves at\n"
"// the end. Simpler! No need to transform pixels back on a per-pixel basis; we handle this in vertex shader!\n"
"\n"
"// Vertex shader should handle only the sizing and rotation aspects. All the magic happens in fragment shader.\n"
"// Note, it seems that numLengthCells is just the length of the ray in pixels...\n"
"\n"
"layout(location = 0) in vec4 aPos;\n"
"layout(location = 1) in vec4 aSizeAndPosition;\n"
"layout(location = 2) in float aRotation;\n"
"layout(location = 3) in float fIntensity;\n"
"layout(location = 4) in float fOpacity;\n"
"layout(location = 5) in int iAnimation;\n"
"layout(location = 6) in int iStyle;\n"
"layout(location = 7) in int iDetail;\n"
"layout(location = 8) in int iDistortion;\n"
"layout(location = 9) in int iAnimationSeed;\n"
"layout(location = 10) in int iLifetime;\n"
"layout(location = 11) in int iCurrFrame;\n"
"layout(location = 12) in vec3 aPrimaryColor;\n"
"layout(location = 13) in vec3 aSecondaryColor;\n"
"layout(location = 14) in float fSecondaryOpacity;\n"
"layout(location = 15) in float aDepth;\n"
"\n"
"uniform vec2 aCanvasAdjustedDimensions;\n"
"\n"
"layout (location = 0) out vec2 quadPos;\n"
"layout (location = 1) flat out int animation;\n"
"layout (location = 2) flat out int style;\n"
"layout (location = 3) flat out int opacity;\n"
"layout (location = 4) flat out int distortion;\n"
"layout (location = 5) out float depth;\n"
"layout (location = 6) out float intensity;\n"
"layout (location = 7) out vec3 primaryColor;\n"
"layout (location = 8) out vec3 secondaryColor;\n"
"layout (location = 9) out float DELETEMEPLOX_waveCyclePos;\n"
"layout (location = 10) flat out int DELETEMEPLOX_colorTypes;\n"
"layout (location = 11) out float opacityAdj;\n"
"layout (location = 12) out vec2 quadSize;\n"
"layout (location = 13) flat out int detail;\n"
"layout (location = 14) out float orbRadius;\n"
"layout (location = 15) out float secondaryOpacity;\n"
"layout (location = 16) flat out int lifetime;\n"
"layout (location = 17) flat out int currFrame;\n"
"layout (location = 18) flat out int animationSeed;\n"
"\n"
"uniform float current_tick;\n"
"\n"
"mat4 rotationMatrix2D(float rotation)\n"
"{\n"
"    // Generates a rotation matrix that rotates a vector counterclockwise in the XY plane by the specified rotation\n"
"    float sterm = sin(rotation);\n"
"    float cterm = cos(rotation);\n"
"    vec4 v1 = vec4(cterm, -sterm, 0, 0);\n"
"    vec4 v2 = vec4(sterm, cterm, 0, 0);\n"
"    vec4 v3 = vec4(0, 0, 1, 0);\n"
"    vec4 v4 = vec4(0, 0, 0, 1);\n"
"    return mat4(v1, v2, v3, v4);\n"
"}\n"
"\n"
"mat4 scalingMatrix2D(float scaleX, float scaleY)\n"
"{\n"
"    // Generates a rotation matrix that rotates a vector counterclockwise in the XY plane by the specified rotation\n"
"    vec4 v1 = vec4(scaleX, 0, 0, 0);\n"
"    vec4 v2 = vec4(0, scaleY, 0, 0);\n"
"    vec4 v3 = vec4(0, 0, 1, 0);\n"
"    vec4 v4 = vec4(0, 0, 0, 1);\n"
"    return mat4(v1, v2, v3, v4);\n"
"}\n"
"\n"
"mat4 translationMatrix2D(float transX, float transY)\n"
"{\n"
"    // Generates a rotation matrix that rotates a vector counterclockwise in the XY plane by the specified rotation\n"
"    vec4 v1 = vec4(1, 0, 0, transX);\n"
"    vec4 v2 = vec4(0, 1, 0, transY);\n"
"    vec4 v3 = vec4(0, 0, 1, 0);\n"
"    vec4 v4 = vec4(0, 0, 0, 1);\n"
"    return mat4(v1, v2, v3, v4);\n"
"}\n"
"\n"
"void main(void)\n"
"{\n"
"// Feeding uniforms into Kodelife...\n"
"// DO NOT TOUCH the first two when porting to Real OpenGL!\n"
"//    vec4 aSizeAndPosition = vec4(500.0, 500.0, 0.5, 0.5);\n"
"//    vec2 aCanvasAdjustedDimensions = vec2(500.0, 500.0);\n"
"//    float aRotation = 0.0;\n"
"//    float aRadius = 300.0; // in pixels - note that all orbs are circular\n"
"//    float fIntensity = 50.0;\n"
"//    float fOpacity = 1.0;\n"
"//    int iAnimation = 1;\n"
"//    int iStyle = 8;\n"
"//    int iDetail = 100;\n"
"//    int iDistortion = 40;\n"
"//    int iAnimationSeed = int(current_tick / 10.0);\n"
"//    int iLifetime = 50;\n"
"//    int iCurrFrame = int(mod(current_tick, iLifetime));\n"
"//    vec3 aPrimaryColor = vec3(0.4, 0.8, 0.8);\n"
"//    vec3 aSecondaryColor = vec3(0.0, 0.6, 1.0);\n"
"//    float aDepth = 0.0;\n"
"\n"
"    vec2 aSize = vec2(aSizeAndPosition[0], aSizeAndPosition[1]);\n"
"    vec2 aPosOnCanvas = (vec2(aSizeAndPosition[2], aSizeAndPosition[3]) - vec2(0.5, 0.5)) * 2.0;\n"
"    \n"
"    vec4 final_pos = aPos * scalingMatrix2D(aSize[0] * 2.0, aSize[1] * 2.0) * rotationMatrix2D(aRotation) * scalingMatrix2D(1.0 / aCanvasAdjustedDimensions[0], 1.0 / aCanvasAdjustedDimensions[1]) * translationMatrix2D(aPosOnCanvas[0], -aPosOnCanvas[1]);\n"
"\n"
"    quadPos = vec2(aPos[0], aPos[1]) * 2.0;\n"
"    // Note, the iVec values are casted to float but treated as int for some weird reason. This means that the\n"
"    // iVecs will contain bits equal to the float representation of their value, but are of type int. We should use intBitsToFloat\n"
"    // to fix this.\n"
"    animation = iAnimation;\n"
"    style = iStyle;\n"
"    distortion = iDistortion;\n"
"    detail = iDetail;\n"
"    depth = aDepth;\n"
"    intensity = fIntensity;\n"
"    //waveCyclePos = aFloatParams[1];\n"
"    opacityAdj = fOpacity;\n"
"    primaryColor = aPrimaryColor;\n"
"    secondaryColor = aSecondaryColor;\n"
"    quadSize = aSize;\n"
"    orbRadius = aSize[0] / 2.0;\n"
"    lifetime = iLifetime;\n"
"    currFrame = iCurrFrame;\n"
"    animationSeed = iAnimationSeed % 10000;\n"
"	secondaryOpacity = fSecondaryOpacity;\n"
"    gl_Position = final_pos;\n"
"    \n"
"}\n";
const std::string VPerlinNoiseShader =
"#version 410 core\n"
"uniform mat4 rotationMatrix;\n"
"\n"
"in vec3 aPos;\n"
"in vec2 aTexCoord;\n"
"\n"
"out vec2 TexCoord;\n"
"\n"
"void main()\n"
"{\n"
"    gl_Position = rotationMatrix * vec4(aPos, 1.0);\n"
"    TexCoord = aTexCoord;\n"
"}\n";
const std::string VCanvasShader =
"#version 410 core\n"
"uniform mat4 rotationMatrix;\n"
"\n"
"in vec3 aPos;\n"
"in vec3 aColor;\n"
"in vec2 aTexCoord;\n"
"\n"
"out vec3 ourColor;\n"
"out vec2 TexCoord;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = rotationMatrix * vec4(aPos, 1.0);\n"
"	ourColor = aColor;\n"
"	TexCoord = aTexCoord;\n"
"}\n";

const std::string FGlowmapShader =
"#version 410 core\n"
"out vec4 FragColor;\n"
"  \n"
"layout (location = 0) in vec2 TexCoord;\n"
"\n"
"uniform vec2 aTexStartPoint;\n"
"uniform vec2 aTexQuadSizes;\n"
"uniform vec2 gridSquareSize;\n"
"uniform sampler2D ourTexture;\n"
"uniform int kernelSize;\n"
"uniform int pad_pixels_per_grid_square;\n"
"uniform int pixel_decimal_place_per_channel_for_linear_glowmap;\n"
"uniform ivec2 num_grid_squares;\n"
"uniform int use_x_axis;\n"
"uniform int second_pass;\n"
"\n"
"float gaussian(float x, float mu, float sigma)\n"
"{\n"
"	float sqrt_2pi = 2.50662827463;\n"
"	float e = 2.718281828;\n"
"	float exp_term = (x - mu) / (sigma);\n"
"	float top = pow(e, (-(exp_term*exp_term)/2.0f));\n"
"	float bottom = sqrt_2pi * sigma;\n"
"	return top / bottom;\n"
"}\n"
"\n"
"int manhattan_distance(int center_x, int center_y, int query_x, int query_y)\n"
"{\n"
"    int delta_x = abs(center_x - query_x);\n"
"    int delta_y = abs(center_y - query_y);\n"
"    \n"
"    return delta_x + delta_y;\n"
"}\n"
"\n"
"float getSumGauss(int kernel_size)\n"
"{\n"
"	float percent_std_dev = 0.66;\n"
"	float sum_gauss = 0.0;\n"
"	int center = int(kernel_size / 2);\n"
"	// First find out the total value under the gaussian curve\n"
"	for (int i = 0; i < kernel_size; i++)\n"
"	{\n"
"        float gauss_val = gaussian(float(i), float(center), float(kernel_size) * percent_std_dev);\n"
"        sum_gauss = sum_gauss + gauss_val;\n"
"	}\n"
"	return sum_gauss;\n"
"}\n"
"\n"
"ivec2 getPixelGridSquareUnpadded(vec2 coords) {\n"
"    vec2 adjusted_coords = coords - aTexStartPoint;\n"
"    int x_coord = int(adjusted_coords[0] / gridSquareSize[0]);\n"
"	int y_coord = int(adjusted_coords[1] / gridSquareSize[1]);\n"
"	return ivec2(x_coord, y_coord);\n"
"}\n"
"\n"
"int obtainPixelDistanceFromFloatVec(vec3 dist_channels) {\n"
"	float pixMult = float(pixel_decimal_place_per_channel_for_linear_glowmap);\n"
"	vec3 inverted_channels = 1.0 - dist_channels;\n"
"	float pixelDistanceIColumn = inverted_channels[2] * pixMult;\n"
"	float pixelDistanceCColumn = inverted_channels[1] * pixMult;\n"
"	float pixelDistance10KColumn = inverted_channels[0] * pixMult;\n"
"	return int((pixelDistance10KColumn * pixMult * pixMult) + (pixelDistanceCColumn * pixMult) + (pixelDistanceIColumn));\n"
"}\n"
"\n"
"vec4 getGlowBoundaries_variable(float epsilon, vec2 texture_uv, sampler2D obj_texture, vec2 texture_size_input, int glow_size, float sum_gauss, bool using_x_axis, bool additive, vec2 pad_fraction_of_output_image, vec2 texture_size_output)\n"
"{\n"
"	float percent_std_dev = 0.66;\n"
"    vec2 onePixel = vec2(1.0, 1.0) / texture_size_input;\n"
"\n"
"	ivec2 pre_transform_quad_index = getPixelGridSquareUnpadded(texture_uv);\n"
"	// To get the texture coordinates: note the scale between the input and the output image.\n"
"	// If the UV coordinates after offset lie in a padded region, then the sample result should be zero.\n"
"	// Otherwise, if the UV coordinates after offset do NOT lie in a padded region, then get the padded pixel\n"
"	// grid square location (xp, yp). Subtract((2 * xp) + 1, (2 * yp) + 1) * padSizeInPixels from the pixel coordinates of the\n"
"	// output; this is the pixel coordinates we need to sample from in the input. Note that if we apply the subtraction\n"
"	// and apply zero minimum bound, then padded pixels in output image will map to row or column zero in the input image\n"
"	// or map to out-of-quad locations, so they will effectively be zero.\n"
"	vec2 texCoords =  vec2(texture_uv[0], texture_uv[1]);\n"
"	texCoords = texCoords - aTexStartPoint;\n"
"	texCoords = texCoords * texture_size_output;\n"
"	texCoords = texCoords - (((2 * pre_transform_quad_index) + vec2(1.0, 1.0)) * pad_pixels_per_grid_square);\n"
"	texCoords = texCoords / texture_size_input;\n"
"	texCoords = texCoords + aTexStartPoint;\n"
"	vec2 texEndPoint = aTexStartPoint + aTexQuadSizes;\n"
"	ivec2 post_transform_quad_index = getPixelGridSquareUnpadded(texCoords);\n"
"	bool sampleNotInPaddedArea = post_transform_quad_index == pre_transform_quad_index && texCoords[0] > aTexStartPoint[0] && texCoords[0] < texEndPoint[0] && texCoords[1] > aTexStartPoint[1] && texCoords[1] < texEndPoint[1];\n"
"	post_transform_quad_index = sampleNotInPaddedArea ? post_transform_quad_index : pre_transform_quad_index;\n"
"\n"
"    int center = int(glow_size / 2);\n"
"	vec4 glowBoundaries = vec4(0.0, 0.0, 0.0, 0.0);\n"
"	int distanceToNearestNonZeroAlphaPixel = int(max(texture_size_input[0], texture_size_input[1]));\n"
"	for (int i = 0; i < glow_size; i++)\n"
"	{\n"
"		// Given the sum of the pixel values under the kernel, blur this pixel using a gaussian blur technique.\n"
"		// Note that this is a normalized gaussian blur, so we take the weighted average of all pixels under this kernel.\n"
"	    float sample_point = float(i - center);\n"
"		float gauss_val = gaussian(float(i), float(center), float(glow_size) * percent_std_dev);\n"
"		vec2 offsetX = vec2(onePixel[0] * sample_point, onePixel[1] * 0.0);\n"
"		vec2 offsetY = vec2(onePixel[0] * 0.0, onePixel[1] * sample_point);\n"
"		// Offset indicates which pixel under this gaussian kernel we are currently considering\n"
"        vec2 offset0 = (float(using_x_axis) * offsetX) + (float(!using_x_axis) * offsetY);\n"
"\n"
"		vec2 texCoords0 = texCoords + offset0;\n"
"        bool texInBounds0 = getPixelGridSquareUnpadded(texCoords0) == post_transform_quad_index && texCoords0[0] > aTexStartPoint[0] && texCoords0[0] < texEndPoint[0] && texCoords0[1] > aTexStartPoint[1] && texCoords0[1] < texEndPoint[1];\n"
"		vec4 sample_value = texture(obj_texture, texCoords0);\n"
"\n"
"		// For linear glow map, what we do is the following:\n"
"		// For each pixel, in the first pass, simply obtain the distance to the nearest pixel with non-zero\n"
"		// alpha value in the axis of choice.\n"
"		// For the second pass, do the same, but this time check the distance to the pixel that has a marked\n"
"		// distance to non-zero alpha pixel in the first axis. Use normalized vector to get the total distance.\n"
"		int distanceToNearestNonZeroAlphaPixelPreviousPass = obtainPixelDistanceFromFloatVec(vec3(sample_value[0], sample_value[1], sample_value[2]));\n"
"		int candidateDistanceToNearestNonZeroAlphaPixel = abs(i - center);\n"
"		candidateDistanceToNearestNonZeroAlphaPixel = (\n"
"			(int(!additive) * candidateDistanceToNearestNonZeroAlphaPixel) +\n"
"			(int(additive) * int(round(length(ivec2(candidateDistanceToNearestNonZeroAlphaPixel, distanceToNearestNonZeroAlphaPixelPreviousPass)))))\n"
"		);\n"
"		bool reducedDistanceToNonZeroPixel = (sample_value[3] > epsilon) && texInBounds0;\n"
"		distanceToNearestNonZeroAlphaPixel = (\n"
"			(int(reducedDistanceToNonZeroPixel) * min(distanceToNearestNonZeroAlphaPixel, candidateDistanceToNearestNonZeroAlphaPixel)) +\n"
"			(int(!reducedDistanceToNonZeroPixel) * distanceToNearestNonZeroAlphaPixel)\n"
"			);\n"
"	}\n"
"	float pixMult = float(pixel_decimal_place_per_channel_for_linear_glowmap);\n"
"	float pixelDistanceIColumn = float(mod(distanceToNearestNonZeroAlphaPixel, pixel_decimal_place_per_channel_for_linear_glowmap)) / pixMult;\n"
"	float pixelDistanceCColumn = float(mod(distanceToNearestNonZeroAlphaPixel /\n"
"		pixel_decimal_place_per_channel_for_linear_glowmap, pixel_decimal_place_per_channel_for_linear_glowmap)) / pixMult;\n"
"	float pixelDistance10KColumn = float(mod(distanceToNearestNonZeroAlphaPixel /\n"
"		(pixel_decimal_place_per_channel_for_linear_glowmap * pixel_decimal_place_per_channel_for_linear_glowmap),\n"
"		pixel_decimal_place_per_channel_for_linear_glowmap)) / pixMult;\n"
"\n"
"	return vec4(1.0 - pixelDistance10KColumn, 1.0 - pixelDistanceCColumn, 1.0 - pixelDistanceIColumn, float(distanceToNearestNonZeroAlphaPixel < max(texture_size_input[0], texture_size_input[1])));\n"
"	//return vec4(glowBoundaries[0], glowBoundaries[1], glowBoundaries[2], min(1.0, 2.0 * glowBoundaries[3]));\n"
"	\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	float epsilon = 0.0001;\n"
"	vec2 texture_size_input = textureSize(ourTexture, 0);\n"
"	vec2 texture_size_output = (textureSize(ourTexture, 0)) + ((1.0 / gridSquareSize) * (2 * pad_pixels_per_grid_square));\n"
"	vec2 pad_fraction_of_output_image = pad_pixels_per_grid_square / texture_size_output;\n"
"	float sumGauss = getSumGauss(kernelSize);\n"
"	vec4 glowValue = getGlowBoundaries_variable(epsilon, TexCoord, ourTexture, texture_size_input, kernelSize, sumGauss, (float(use_x_axis) > epsilon), bool(second_pass), pad_fraction_of_output_image, texture_size_output);\n"
"	FragColor = glowValue;\n"
"}\n";
const std::string FObjectTextureShader =
"#version 410 core\n"
"layout (location = 0) in vec2 texture_uv;\n"
"layout (location = 1) in vec2 texture_pos;\n"
"layout (location = 2) in vec2 texture_size;\n"
"layout (location = 3) in vec2 fragment_pos;\n"
"layout (location = 4) in vec2 texture_start_point;\n"
"layout (location = 5) flat in ivec2 num_frames;\n"
"layout (location = 6) in float alpha_strength;\n"
"layout (location = 7) in float depth;\n"
"layout (location = 8) in vec4 glow_color;\n"
"layout (location = 9) in float glow_noise;\n"
"layout (location = 10) in vec2 texture_bounds_min;\n"
"layout (location = 11) in vec2 texture_bounds_max;\n"
"layout (location = 12) flat in int render_category;\n"
"layout (location = 13) in vec2 texture_raw_pos;\n"
"layout (location = 14) flat in int glowRadius;\n"
"layout (location = 15) flat in int blendMode;\n"
"layout (location = 16) in vec2 decayPoint;\n"
"layout (location = 17) in float decayMaxRadius;\n"
"layout (location = 18) in float decayMinRadius;\n"
"layout (location = 19) in vec2 canvPosition;\n"
"\n"
"out vec4 out_color;\n"
"\n"
"uniform sampler2D obj_texture;\n"
"uniform sampler2D glow_map;\n"
"uniform int current_tick;\n"
"uniform int glowmap_pad_size;\n"
"uniform sampler3D perlin_noise;\n"
"uniform int pixel_decimal_place_per_channel_for_linear_glowmap;\n"
"\n"
"const int renderCategoryObjectCartesian = 0;\n"
"const int renderCategoryText = 1;\n"
"const int renderCategoryObjectPolar = 2;\n"
"const int renderCategoryObjectCartesianGrayscale = 3;\n"
"const float PI = 3.14159;\n"
"\n"
"// This should match enum blendMode in opengl.h.\n"
"\n"
"const int blendNormal = 0;      //      Normal drawing\n"
"const int blendMultiply = 1;      //      Darkens images\n"
"const int blendOverlay = 2;      //      Combine multiply/screen\n"
"const int blendScreen = 3;      //      Brightens images\n"
"const int blendHardLight = 4;\n"
"const int blendCompositeNormal = 5;\n"
"\n"
"//	Classic Perlin 3D Noise \n"
"//	by Stefan Gustavson\n"
"//\n"
"//  Found at https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n"
"vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\n"
"vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n"
"vec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n"
"\n"
"float cnoise(vec3 P){\n"
"  vec3 Pi0 = floor(P); // Integer part for indexing\n"
"  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n"
"  Pi0 = mod(Pi0, 289.0);\n"
"  Pi1 = mod(Pi1, 289.0);\n"
"  vec3 Pf0 = fract(P); // Fractional part for interpolation\n"
"  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n"
"  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n"
"  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n"
"  vec4 iz0 = Pi0.zzzz;\n"
"  vec4 iz1 = Pi1.zzzz;\n"
"\n"
"  vec4 ixy = permute(permute(ix) + iy);\n"
"  vec4 ixy0 = permute(ixy + iz0);\n"
"  vec4 ixy1 = permute(ixy + iz1);\n"
"\n"
"  vec4 gx0 = ixy0 / 7.0;\n"
"  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n"
"  gx0 = fract(gx0);\n"
"  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n"
"  vec4 sz0 = step(gz0, vec4(0.0));\n"
"  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n"
"  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n"
"\n"
"  vec4 gx1 = ixy1 / 7.0;\n"
"  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n"
"  gx1 = fract(gx1);\n"
"  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n"
"  vec4 sz1 = step(gz1, vec4(0.0));\n"
"  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n"
"  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n"
"\n"
"  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n"
"  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n"
"  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n"
"  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n"
"  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n"
"  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n"
"  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n"
"  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n"
"\n"
"  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n"
"  g000 *= norm0.x;\n"
"  g010 *= norm0.y;\n"
"  g100 *= norm0.z;\n"
"  g110 *= norm0.w;\n"
"  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n"
"  g001 *= norm1.x;\n"
"  g011 *= norm1.y;\n"
"  g101 *= norm1.z;\n"
"  g111 *= norm1.w;\n"
"\n"
"  float n000 = dot(g000, Pf0);\n"
"  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n"
"  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n"
"  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n"
"  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n"
"  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n"
"  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n"
"  float n111 = dot(g111, Pf1);\n"
"\n"
"  vec3 fade_xyz = fade(Pf0);\n"
"  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n"
"  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n"
"  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n"
"  return 2.2 * n_xyz;\n"
"}\n"
"\n"
"int obtainPixelDistanceFromFloatVec(vec3 dist_channels) {\n"
"	float pixMult = float(pixel_decimal_place_per_channel_for_linear_glowmap);\n"
"	vec3 inverted_channels = 1.0 - dist_channels;\n"
"	float pixelDistanceIColumn = inverted_channels[2] * pixMult;\n"
"	float pixelDistanceCColumn = inverted_channels[1] * pixMult;\n"
"	float pixelDistance10KColumn = inverted_channels[0] * pixMult;\n"
"	return int((pixelDistance10KColumn * pixMult * pixMult) + (pixelDistanceCColumn * pixMult) + (pixelDistanceIColumn));\n"
"}\n"
"\n"
"ivec2 getPixelGridSquareUnpadded(vec2 coords, vec2 texture_size, vec2 texture_start_point) {\n"
"    vec2 adjusted_coords = coords - texture_start_point;\n"
"    int x_coord = int(coords[0] / texture_size[0]);\n"
"	int y_coord = int(coords[1] / texture_size[1]);\n"
"	return ivec2(x_coord, y_coord);\n"
"}\n"
"\n"
"vec4 sampleFromGlowMap(vec2 texture_uv, vec2 texture_size, vec2 texture_start_point)\n"
"{\n"
"	// Convert the raw (unpadded) fragment pos to properly deal with glowmap padding\n"
"	ivec2 quad_index = getPixelGridSquareUnpadded(texture_uv, texture_size, texture_start_point);\n"
"	vec2 glowmap_fragment_pos = texture_uv - texture_start_point;\n"
"	glowmap_fragment_pos = glowmap_fragment_pos * textureSize(obj_texture, 0);\n"
"	glowmap_fragment_pos = glowmap_fragment_pos + (((2 * quad_index) + vec2(1.0, 1.0)) * glowmap_pad_size);\n"
"	glowmap_fragment_pos = glowmap_fragment_pos / textureSize(glow_map, 0);\n"
"	return texture(glow_map, glowmap_fragment_pos);\n"
"}\n"
"\n"
"float getGlowBoundaries(vec2 texture_size, ivec2 num_frames, vec2 texture_uv, vec2 texture_start_point) {\n"
"	vec2 totalTextureSize = texture_size * num_frames;\n"
"	vec2 textureUVStartingAtZero = texture_uv - texture_start_point;\n"
"	vec2 textureUVFromZeroToOne = textureUVStartingAtZero / totalTextureSize;\n"
"	vec4 glowmapSampleValue = texture(glow_map, (vec2(textureUVFromZeroToOne[0], textureUVFromZeroToOne[1])));\n"
"	int distanceFromObject = obtainPixelDistanceFromFloatVec(vec3(glowmapSampleValue[0], glowmapSampleValue[1], glowmapSampleValue[2]));\n"
"	float glowBoundaries = 1.0 - (float(distanceFromObject) / float(max(1, glowRadius)));\n"
"	glowBoundaries = glowBoundaries * float(distanceFromObject <= glowRadius) * glowmapSampleValue[3];\n"
"	float distanceFromDecayPoint = length(decayPoint - canvPosition);\n"
"	bool useUniformGlowValue = (decayMaxRadius < 0) && (decayMinRadius < 0);\n"
"	float glowStrengthMultiplierRing = max(0.0, 1.0 - (abs(distanceFromDecayPoint - ((decayMaxRadius + decayMinRadius) / 2.0)) / (float(decayMaxRadius == decayMinRadius) + (decayMaxRadius - decayMinRadius) / 2.0)));\n"
"	float glowStrengthMultiplierPeak = max(0.0, 1.0 - (distanceFromDecayPoint / decayMaxRadius));\n"
"	float glowStrengthMultiplierToUse = mix(glowStrengthMultiplierPeak, glowStrengthMultiplierRing, float(decayMinRadius > 0.0));\n"
"	float finalGlowStrengthMultiplier = mix(glowStrengthMultiplierToUse, 1.0, float(useUniformGlowValue));\n"
"	return glowBoundaries * finalGlowStrengthMultiplier;\n"
"}\n"
"\n"
"vec4 getGlowColor_PerlinNoise(float glowNoisePeriodXY, float alphaNoiseTimeAxis, float epsilon, vec4 color, vec2 texture_size, vec2 texture_uv, sampler2D obj_texture, float perlinNoiseGlow, vec2 texture_start_point, ivec2 num_frames)\n"
"{\n"
"	float glowBoundaries = getGlowBoundaries(texture_size, num_frames, texture_uv, texture_start_point);\n"
"	\n"
"	vec4 glowColor = vec4(glow_color[0], glow_color[1], glow_color[2], glow_color[3] * ((perlinNoiseGlow / 2.0) + 0.5)) * glowBoundaries;\n"
"	\n"
"	return glowColor;\n"
"}\n"
"\n"
"vec4 getGlowColor_Static(float epsilon, vec4 color, vec2 texture_size, vec2 texture_uv, sampler2D obj_texture, vec2 texture_start_point, ivec2 num_frames)\n"
"{\n"
"	float glowBoundaries = getGlowBoundaries(texture_size, num_frames, texture_uv, texture_start_point);\n"
"	\n"
"	vec4 glowColor = vec4(glow_color[0], glow_color[1], glow_color[2], glow_color[3]) * glowBoundaries;\n"
"	\n"
"	return glowColor;\n"
"}\n"
"\n"
"vec4 getTextColor(vec4 color, vec2 texture_uv)\n"
"{\n"
"	float textAlpha = texture(obj_texture, vec2(texture_uv[0], texture_uv[1]))[0];\n"
"\n"
"	vec4 textColor = vec4(color[0], color[1], color[2], textAlpha);\n"
"\n"
"	return textColor;\n"
"}\n"
"\n"
"float sampleNoiseFBM(vec3 sampler) {\n"
"    return texture(perlin_noise, vec3(sampler[0], sampler[1], sampler[2]))[0];\n"
"}\n"
"\n"
"float rand(vec2 co){\n"
"  // Canonical PRNG from https://stackoverflow.com/questions/12964279/whats-the-origin-of-this-glsl-rand-one-liner\n"
"  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n"
"}\n"
"\n"
"float sampleNoisePerlin(vec3 sampler) {\n"
"    return texture(perlin_noise, vec3(sampler[0], sampler[1], sampler[2]))[1];\n"
"}\n"
"\n"
"float fbm(vec2 p, float time)\n"
"{\n"
"    // Fractal Brownian Motion using Perlin noise\n"
"     float v = 0.0;\n"
"     float amp = 0.3;\n"
"     float freq = 20;\n"
"     int octaves = 3;\n"
"     for (int i = 0; i < octaves; i++)\n"
"         v += cnoise(vec3(((p + vec2(1000.0, 1000.0)) * (i * freq)), time / 100)) * (amp / (i + 1));\n"
"\n"
"     return v;\n"
"}\n"
"\n"
"float stackedPerlin(vec2 p, float time)\n"
"{\n"
"    // Fractal Brownian Motion using Perlin noise\n"
"    float v = 1.0;\n"
"    int octaves = 5;\n"
"	float dir_multiplier = 0.25;\n"
"    for (int i = 0; i < octaves; i++) {\n"
"        int rseed = i + 123;\n"
"        vec2 rand_dir = normalize(vec2(rand(vec2(rseed, rseed)), rand(vec2(rseed+1, rseed+1)))) * dir_multiplier;\n"
"        v *= sampleNoiseFBM(vec3((p * 5 * (rand(vec2(rseed+2, rseed-2)) - 0.5)) + time*rand_dir, 0.0)) * 2.0;\n"
"    }\n"
"\n"
"    return v / 2.0;\n"
"}\n"
"\n"
"vec4 sampleCircular(sampler2D tex_sample) {\n"
"    // This is used for shockwaves. Works just like regular texture painting, except we use the following UV mapping:\n"
"	// x_tex to quad angle, and y_tex to quad distance from center\n"
"	float distanceFromCenter = length(vec2(texture_raw_pos[0], texture_raw_pos[1]));\n"
"	vec2 polarTexPos = vec2(atan(texture_raw_pos[1], texture_raw_pos[0]) / (2 * PI), 0.5 - (2.0 * distanceFromCenter));\n"
"	vec2 fixedTexPos = texture_bounds_min;\n"
"	vec2 texPositionOffset = (texture_bounds_max - fixedTexPos) / 2.0;\n"
"	vec2 polarTexPos2d = vec2(polarTexPos[0] * texture_size[0], polarTexPos[1] * texture_size[1]) + fixedTexPos + texPositionOffset;\n"
"	return vec4(texture(tex_sample, polarTexPos2d)) * float(distanceFromCenter < 0.5);\n"
"}\n"
"\n"
"float stackedPerlin(vec3 p) {\n"
"    return stackedPerlin(vec2(p.x, p.y), p.z);\n"
"}\n"
"\n"
"void main(void)\n"
"{		\n"
"	float epsilon = 0.01;\n"
"	float alphaNoisePeriodTime = 5;\n"
"	float alphaNoisePeriodXY = 0.2f;\n"
"	float glowNoisePeriodXY = 10.0f;\n"
"\n"
"	vec4 realColorCartesian = texture(obj_texture, vec2(texture_uv[0], texture_uv[1]));\n"
"	vec4 realColorPolar = sampleCircular(obj_texture);\n"
"	vec4 realColor = (\n"
"		(realColorCartesian * float(render_category == renderCategoryObjectCartesian || render_category == renderCategoryObjectCartesianGrayscale)) +\n"
"        (realColorPolar * float(render_category == renderCategoryObjectPolar))\n"
"	);\n"
"\n"
"	float alphaNoiseTimeAxis = (float(current_tick) / max(alphaNoisePeriodTime, epsilon));\n"
"	float perlinNoise = (sampleNoisePerlin(vec3(fragment_pos[0] * alphaNoisePeriodXY, fragment_pos[1] * alphaNoisePeriodXY, alphaNoiseTimeAxis)) + 0.0f);\n"
"	float alphaNoise = (perlinNoise - 0.5) * ((1.0 - (2.0 * abs(alpha_strength - 0.5))) * glow_noise);\n"
"	alphaNoise = (float(alphaNoise < 0) * -1.0) * (sqrt(abs(alphaNoise)) / (2.0 * sqrt(0.5)));\n"
"	\n"
"	vec4 glowColorPerlin = getGlowColor_PerlinNoise(20.0f, alphaNoiseTimeAxis, epsilon, realColor, texture_size, texture_uv, obj_texture, perlinNoise, texture_start_point, num_frames);\n"
"	vec4 glowColorStatic = getGlowColor_Static(epsilon, realColor, texture_size, texture_uv, obj_texture, texture_start_point, num_frames);\n"
"	vec4 textColor = getTextColor(glow_color, texture_uv);\n"
"	bool useStaticNoise = (glow_noise < epsilon);\n"
"	vec4 glowColor = (float(useStaticNoise) * glowColorStatic) + (float(!useStaticNoise) * glowColorPerlin);\n"
"	\n"
"	// If a glow color is specified, use glow instead of using the ship texture\n"
"	// Also add noise to the glow as appropriate\n"
"	// Glow size is controlled via the quad size; we use separate quads for glow and standard ship texture\n"
"	bool useGlow = (glow_color[3] > epsilon);\n"
"	\n"
"	\n"
"	vec4 textureColor = vec4(realColor[0], realColor[1], realColor[2], (realColor[3] * alpha_strength));\n"
"	vec4 objectColor = (float(!useGlow) * textureColor) + (float(useGlow) * glowColor);\n"
"	float grayscaleIntensity = length(vec3(objectColor[0], objectColor[1], objectColor[2]));\n"
"	vec4 grayscaleColor = vec4(grayscaleIntensity, grayscaleIntensity, grayscaleIntensity, objectColor[3]);\n"
"\n"
"	bool usePreMultipliedAlpha = (\n"
"		(blendMode == blendScreen)\n"
"	);\n"
"\n"
"    vec4 finalColor = (\n"
"        (objectColor * float(render_category == renderCategoryObjectCartesian || render_category == renderCategoryObjectPolar)) +\n"
"        (textColor * float(render_category == renderCategoryText)) +\n"
"		(grayscaleColor * float(render_category == renderCategoryObjectCartesianGrayscale))\n"
"	);\n"
"	finalColor[3] += (alphaNoise * realColor[3]) * float(render_category == renderCategoryObjectCartesian || render_category == renderCategoryObjectPolar) * float(!useGlow);\n"
"\n"
"	bool alphaIsZero = finalColor[3] < epsilon;\n"
"	gl_FragDepth = depth + float(alphaIsZero && (glowColor[3] < epsilon));\n"
"\n"
"	vec3 finalColorRGB = (vec3(finalColor[0], finalColor[1], finalColor[2]) * float(!usePreMultipliedAlpha)) + (vec3(finalColor[0], finalColor[1], finalColor[2]) * float(usePreMultipliedAlpha) * finalColor[3]);\n"
"\n"
"	out_color = vec4(finalColorRGB[0], finalColorRGB[1], finalColorRGB[2], finalColor[3]);\n"
"}\n";
const std::string FRayShader =
"#version 410 core\n"
"\n"
"// This shader implements the following effects: orb, ray, lightning.\n"
"\n"
"layout (location = 0) in vec2 quadPos;\n"
"layout (location = 1) flat in int rayReshape;\n"
"layout (location = 2) flat in int rayWidthAdjType;\n"
"layout (location = 3) flat in int rayOpacity;\n"
"layout (location = 4) flat in int rayGrainyTexture;\n"
"layout (location = 5) in float depth;\n"
"layout (location = 6) in float intensity;\n"
"layout (location = 7) in vec3 primaryColor;\n"
"layout (location = 8) in vec3 secondaryColor;\n"
"layout (location = 9) in float rayWaveCyclePos;\n"
"layout (location = 10) flat in int colorTypes; // TODO: replace with something more useful\n"
"layout (location = 11) in float opacityAdj;\n"
"layout (location = 12) flat in int effectType;\n"
"layout (location = 13) in float seed;\n"
"layout (location = 14) in vec2 quadSize;\n"
"layout (location = 15) flat in int orbAnimation; //\n"
"layout (location = 16) flat in int orbStyle; //\n"
"layout (location = 17) flat in int orbDistortion;\n"
"layout (location = 18) flat in int orbDetail;\n"
"layout (location = 19) in float orbSecondaryOpacity;\n"
"layout (location = 20) flat in int orbLifetime;\n"
"layout (location = 21) flat in int orbCurrFrame;\n"
"layout (location = 22) flat in int blendMode;\n"
"layout (location = 23) flat in float rotation;\n"
"layout (location = 24) flat in int particleDestiny;\n"
"layout (location = 25) flat in float particleMinRadius;\n"
"\n"
"uniform float current_tick;\n"
"uniform sampler3D perlin_noise;\n"
"\n"
"out vec4 fragColor;\n"
"\n"
"// This should match enum blendMode in opengl.h.\n"
"\n"
"const int blendNormal = 0;      //      Normal drawing\n"
"const int blendMultiply = 1;      //      Darkens images\n"
"const int blendOverlay = 2;      //      Combine multiply/screen\n"
"const int blendScreen = 3;      //      Brightens images\n"
"const int blendHardLight = 4;\n"
"const int blendCompositeNormal = 5;\n"
"\n"
"// This should match enum effectType in opengl.h.\n"
"\n"
"const int effectTypeRay = 0;\n"
"const int effectTypeLightning = 1;\n"
"const int effectTypeOrb = 2;\n"
"const int effectTypeFlare = 3;\n"
"const int effectTypeParticle = 4;\n"
"\n"
"const float PI = 3.14159;\n"
"const float BLOB_WAVE_SIZE = 0.3;\n"
"const float WAVY_WAVELENGTH_FACTOR = 1.0;\n"
"const float JAGGED_AMPLITUDE = 0.45;\n"
"const float JAGGED_WAVELENGTH_FACTOR = 0.33;\n"
"const float WHIPTAIL_AMPLITUDE = 0.45;\n"
"const float WHIPTAIL_WAVELENGTH_FACTOR = 1.0;\n"
"const float WHIPTAIL_DECAY = 0.13;\n"
"\n"
"// Copy of EWidthAdjTypes enum from SFXRay.cpp\n"
"const int widthAdjStraight = 0;\n"
"const int widthAdjBlob = 1;\n"
"const int widthAdjDiamond = 2;\n"
"const int widthAdjJagged = 3;\n"
"const int widthAdjOval = 4;\n"
"const int widthAdjTaper = 5;\n"
"const int widthAdjCone = 6;\n"
"const int widthAdjWhiptail = 7;\n"
"const int widthAdjSword = 8;\n"
"\n"
"// Copy of EOpacityTypes enum from SFXRay.cpp (except for opacityFlareGlow)\n"
"const int opacityGlow = 1;\n"
"const int opacityGrainy = 2;\n"
"const int opacityTaperedGlow = 3;\n"
"const int opacityTaperedExponentialGlow = 4;\n"
"const int opacityFlareGlow = -1;\n"
"const int opacityLengthwise = -2;\n"
"\n"
"const int colorTypeDefault = 0;\n"
"const int colorTypeGlow = 1;\n"
"const int colorTypeLengthGradient = -1;\n"
"\n"
"\n"
"//  Classic Perlin 3D Noise\n"
"//  by Stefan Gustavson\n"
"//\n"
"//  Found at https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n"
"vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\n"
"vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n"
"vec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n"
"\n"
"float rand(vec2 co){\n"
"  // Canonical PRNG from https://stackoverflow.com/questions/12964279/whats-the-origin-of-this-glsl-rand-one-liner\n"
"  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n"
"}\n"
"\n"
"// BEGIN RAY AND LIGHTNING SUBSHADER\n"
"\n"
"float widthCone(float rInputValue)\n"
"{\n"
"    return (-(rInputValue - 1.0) / 2.0);\n"
"}\n"
"\n"
"float widthDiamond(float rInputValue)\n"
"{\n"
"    return (1.0 - abs(rInputValue));\n"
"}\n"
"\n"
"float widthSword(float rInputValue)\n"
"    {\n"
"    // Just like taper, but with triangular rather than circular head from head to peak\n"
"    float rQuadHalfLength = 1.0;\n"
"    float rSwordFraction = 5.0;\n"
"    float rPeakDistance = ((2.0 * rQuadHalfLength) / (rSwordFraction / 1.0));\n"
"    float rPeakPoint = rQuadHalfLength - rPeakDistance;\n"
"    float rTipCoord = ((rPeakPoint - rInputValue) / rPeakDistance);\n"
"    bool inTipPortion = rQuadHalfLength - rInputValue < rPeakDistance;\n"
"    float rTipWidth = (1.0 - abs(rTipCoord)) * float(inTipPortion);\n"
"    // Tapered from peak onwards\n"
"    float rTaperedDY = (2.0 * rQuadHalfLength) - rPeakDistance;\n"
"    float rTaperedWidth = ((rInputValue - (-rQuadHalfLength)) / rTaperedDY) * float(!inTipPortion);\n"
"    return rTaperedWidth + max(rTipWidth, 0);\n"
"    }\n"
"\n"
"float widthTapered(float rInputValue)\n"
"{\n"
"    // Circular from head to peak\n"
"    float rQuadHalfLength = 1.0;\n"
"    float rTaperFraction = 8.0;\n"
"    float rPeakDistance = ((2.0 * rQuadHalfLength) / (rTaperFraction / 1.0));\n"
"    float rPeakPoint = rQuadHalfLength - rPeakDistance;\n"
"    float rCircleCoord = ((rPeakPoint - rInputValue) / rPeakDistance);\n"
"    bool inCircularPortion = rQuadHalfLength - rInputValue < rPeakDistance;\n"
"    float rCircleWidth = sqrt(rQuadHalfLength - (rCircleCoord * rCircleCoord)) * float(inCircularPortion);\n"
"    // Tapered from peak onwards\n"
"    float rTaperedDY = (2.0 * rQuadHalfLength) - rPeakDistance;\n"
"    float rTaperedWidth = ((rInputValue - (-rQuadHalfLength)) / rTaperedDY) * float(!inCircularPortion);\n"
"    return rTaperedWidth + max(rCircleWidth, 0);\n"
"}\n"
"\n"
"float widthOval(float rInputValue)\n"
"    {\n"
"    float rMidPoint = 0.0;\n"
"    float rQuadHalfLength = 1.0;\n"
"    //  If before the midpoint, then we have a distance of sqrt(0.5 - (pos^2))\n"
"    float rBeforeMidpointValue = sqrt((rQuadHalfLength - (rInputValue * rInputValue)) * (1 / rQuadHalfLength)) * float(rInputValue < rMidPoint);\n"
"    //  If after the midpoint, then we have a distance of sqrt(0.5 + (pos^2))\n"
"    float rAfterMidpointValue = sqrt((rQuadHalfLength - (rInputValue * rInputValue)) * (1 / rQuadHalfLength)) * float(rInputValue > rMidPoint);\n"
"    return rBeforeMidpointValue + rAfterMidpointValue;\n"
"    }\n"
"\n"
"float widthWave(float rInputValue, float rAmplitude, float rWavelength, float rDecay, float rPhase)\n"
"    {\n"
"    //  Wavelength decays (increases with each cycle)\n"
"    float rStartWavelength = max(0.001, rWavelength);\n"
"\n"
"    //  Cycle around a mid point which is 1.0 - amplitude\n"
"    float rPos = 1.0 - rAmplitude;\n"
"\n"
"    //  Offset wave to produce an animation\n"
"    float rAngleStart = 2.0 * PI * (1.0 - rPhase);\n"
"\n"
"    //  Determine the wavelength and the angle\n"
"    float rPointWavelength = (rStartWavelength + (rInputValue * rDecay));\n"
"    float rAngle = rAngleStart + (2.0 * PI * (rInputValue / rPointWavelength));\n"
"    return (sin(rAngle) * rAmplitude) + rPos;\n"
"\n"
"\n"
"    }\n"
"\n"
"float widthRandomWaves(float rInputValue, float rAmplitude, float rWavelength, float seed)\n"
"    //  Note, rAmplitude and rWavelength both assume that the quad's size is 2.0.\n"
"    //\n"
"    {\n"
"    int i, v;\n"
"    int iNumHarmonics = 2;\n"
"\n"
"    //  Peak size is related to intensity.\n"
"    float iStdPeakSize = max(0.001, rWavelength);\n"
"    //  Cycle around the mid-point\n"
"    float rPos = 1.0 - rAmplitude;\n"
"\n"
"    //  Set a value to store the last sine function result\n"
"    float rRandValue = rand(vec2(current_tick + seed, current_tick + seed));\n"
"    float rPrevSinValue = int(rRandValue * 100.0);\n"
"    float rTotalSumValue = 0;\n"
"\n"
"    //  Loop 5 times\n"
"    for (i = 0; i < iNumHarmonics; i++)\n"
"        {\n"
"        //  Amplitude is between 0.2 and 0.8 times rAmplitude, divided by number of harmonics\n"
"        float rSinusAmplitude = (float(rAmplitude) * ((rRandValue * 0.8) + 0.2)) / float(iNumHarmonics);\n"
"        rRandValue = rand(vec2(rRandValue + 1, rRandValue + 1));\n"
"        //  Wavelength is between 0.5 and 2.5 times standard peak size\n"
"        float rSinusWavelength = ((0.5 + (rRandValue * 2.0)) * float(iStdPeakSize));\n"
"        float rSinusFrequency = (2.0 * PI) / rSinusWavelength;\n"
"        float rSinusPhase = rRandValue;\n"
"        rPrevSinValue = sin(((rInputValue - 1.0) * rSinusFrequency) + rSinusPhase) * rSinusAmplitude;\n"
"        rTotalSumValue += rPrevSinValue;\n"
"        rRandValue = rand(vec2(rRandValue + 2, rRandValue + 2));\n"
"        }\n"
"    return (rTotalSumValue + rPos);\n"
"    }\n"
"\n"
"vec3 blendVectors(vec3 rgbFrom, vec3 rgbTo, float rFade)\n"
"{\n"
"    float rFadeVal = max(0.0, min(1.0, rFade));\n"
"    vec3 diff = rgbTo - rgbFrom;\n"
"    return (rgbFrom + (diff * rFadeVal));\n"
"}\n"
"\n"
"vec3 calcColorGlowLengthGradient(vec3 primaryColor, vec3 secondaryColor, float lengthPos)\n"
"{\n"
"    float lengthPosNorm = lengthPos + 0.5;\n"
"	return mix(primaryColor, secondaryColor, lengthPosNorm);\n"
"}\n"
"\n"
"vec3 calcColorGlowWidthGradient(vec3 primaryColor, vec3 secondaryColor, float rWidthCount, float iIntensity, float distanceFromCenter)\n"
"{\n"
"    // Note, Intensity should be a percentage of the ray's width.\n"
"    float BRIGHT_FACTOR = 0.0025;\n"
"\n"
"    float centerBlendIntensity = min(50.0, iIntensity) / 50.0;\n"
"    float rBrightPoint = BRIGHT_FACTOR * rWidthCount * iIntensity;\n"
"    vec3 innerColor = blendVectors(primaryColor, vec3(1.0, 1.0, 1.0), centerBlendIntensity);\n"
"\n"
"    float rFadeInc = max(0.0f, 1.0f / (rWidthCount - rBrightPoint)) * (distanceFromCenter - rBrightPoint);\n"
"    vec3 outerColor = blendVectors(secondaryColor, primaryColor, 1.0f - rFadeInc);\n"
"\n"
"    float useInnerColor = float(distanceFromCenter < rBrightPoint);\n"
"    float useOuterColor = float(distanceFromCenter >= rBrightPoint);\n"
"    return (innerColor * useInnerColor) + (outerColor * useOuterColor);\n"
"}\n"
"\n"
"vec3 calcColorGlow(vec3 primaryColor, vec3 secondaryColor, float rWidthCount, float iIntensity, float distanceFromCenter, float widthCalcPos)\n"
"{\n"
"    return (\n"
"        (calcColorGlowWidthGradient(primaryColor, secondaryColor, rWidthCount, iIntensity, distanceFromCenter) * float(colorTypes == colorTypeGlow || colorTypes == colorTypeDefault)) +\n"
"        (calcColorGlowLengthGradient(primaryColor, secondaryColor, widthCalcPos) * float(colorTypes == colorTypeLengthGradient))\n"
"    );\n"
"}\n"
"\n"
"float calcOpacityGlow(float rWidthCount, float rIntensity, float distanceFromCenter)\n"
"{\n"
"    float SOLID_FACTOR = 0.004;\n"
"    float MIN_GLOW_LEVEL = 0.6;\n"
"    float GLOW_FACTOR = 0.004;\n"
"\n"
"    // Solid opacity from center to peak\n"
"    float rPeakPoint = SOLID_FACTOR * rIntensity * rWidthCount;\n"
"    float useSolid = float(distanceFromCenter < rPeakPoint);\n"
"\n"
"    // Decay exponentially to edge\n"
"    float useNonSolid = float(distanceFromCenter >= rPeakPoint);\n"
"    float rGlowLevel = MIN_GLOW_LEVEL + (rIntensity * GLOW_FACTOR);\n"
"    float rGlowInc = max(0.0f, 1.0f / (rWidthCount - rPeakPoint)) * (distanceFromCenter - rPeakPoint);\n"
"    float rGlow = 1.0;\n"
"    float outerGlow = rGlowLevel * (rGlow - rGlowInc) * (rGlow - rGlowInc);\n"
"\n"
"    return (useSolid) + (useNonSolid * outerGlow);\n"
"}\n"
"\n"
"float calcOpacityTaperedGlow(float rWidthCount, float rIntensity, float distanceFromCenter_w, float coordinate_l)\n"
"{\n"
"    float SOLID_FACTOR = 0.004;\n"
"    float MIN_GLOW_LEVEL = 0.6;\n"
"    float GLOW_FACTOR = 0.004;\n"
"    float rLengthCount = 1.0;\n"
"\n"
"    float rPeakPoint = SOLID_FACTOR * rIntensity * rWidthCount;\n"
"    // Fade out linearly after the 1/3 point\n"
"    float rMinFadePoint = 0.0; // TODO: fix this to 300 pixels\n"
"    float rFadePoint = max(rMinFadePoint, 0.3);\n"
"    float rTaperInc = max(0.0, 1.0 / (2.0 - rFadePoint));\n"
"\n"
"    // Solid from center to peak plus taper\n"
"    // If before the fade point lengthwise, and before the peak point widthwise, then solid\n"
"    float useSolid = float(distanceFromCenter_w < rPeakPoint);// && (coordinate_l < rFadePoint));\n"
"\n"
"    // Otherwise, if after the fade point lengthwise, decrease by taperInc\n"
"    float taperComponent = (1.0 - (max(0.0, rFadePoint - coordinate_l)) * rTaperInc);\n"
"\n"
"\n"
"    // Decay exponentially to edge\n"
"    float useNontaperedOpacity = float(coordinate_l < rFadePoint);\n"
"    float useNonSolid = float(distanceFromCenter_w >= rPeakPoint);\n"
"    float rGlowLevel = MIN_GLOW_LEVEL + (rIntensity * GLOW_FACTOR);\n"
"    float rGlowInc = max(0.0f, 1.0f / (rWidthCount - rPeakPoint)) * (distanceFromCenter_w - rPeakPoint);\n"
"    float rGlow = 1.0;\n"
"    float outerGlow = rGlowLevel * (rGlow - rGlowInc) * (rGlow - rGlowInc) * taperComponent;\n"
"\n"
"    return (useSolid * taperComponent) + (useNonSolid * outerGlow);\n"
"}\n"
"\n"
"float calcOpacityTaperedExponentialGlow(float rWidthCount, float rIntensity, float distanceFromCenter_w, float coordinate_l)\n"
"{\n"
"    float SOLID_FACTOR = 0.004;\n"
"    float MIN_GLOW_LEVEL = 0.6;\n"
"    float GLOW_FACTOR = 0.004;\n"
"    float rLengthCount = 1.0;\n"
"\n"
"    float rPeakPoint = SOLID_FACTOR * rIntensity * rWidthCount;\n"
"    // Fade out linearly after the 1/3 point\n"
"    float rMinFadePoint = 0.0; // TODO: fix this to 300 pixels\n"
"    float rFadePoint = max(rMinFadePoint, 0.3);\n"
"    float rTaperInc = max(0.0, 1.0 / (2.0 - rFadePoint));\n"
"\n"
"    // Solid from center to peak plus taper\n"
"    // If before the fade point lengthwise, and before the peak point widthwise, then solid\n"
"    float useSolid = float(distanceFromCenter_w < rPeakPoint);// && (coordinate_l < rFadePoint));\n"
"\n"
"    // Otherwise, if after the fade point lengthwise, decrease by taperInc\n"
"    float taperComponent = (1.0 - (max(0.0, rFadePoint - coordinate_l)) * rTaperInc);\n"
"\n"
"\n"
"    // Decay exponentially to edge\n"
"    float useNontaperedOpacity = float(coordinate_l < rFadePoint);\n"
"    float useNonSolid = float(distanceFromCenter_w >= rPeakPoint);\n"
"    float rGlowLevel = MIN_GLOW_LEVEL + (rIntensity * GLOW_FACTOR);\n"
"    float rGlowInc = max(0.0f, 1.0f / (rWidthCount - rPeakPoint)) * (distanceFromCenter_w - rPeakPoint);\n"
"    float rGlow = 1.0;\n"
"    float outerGlow = rGlowLevel * (rGlow - rGlowInc) * (rGlow - rGlowInc) * taperComponent * taperComponent;\n"
"\n"
"    return (useSolid * taperComponent * taperComponent) + (useNonSolid * outerGlow);\n"
"}\n"
"\n"
"float calcOpacityFlareGlow(float distanceFromCenter_w, float coordinate_l)\n"
"{\n"
"    const float BLOOM_FACTOR = 1.2;\n"
"    float rDist = (1.0 - abs(distanceFromCenter_w));\n"
"    float rSpread = (1.0 - abs(coordinate_l));\n"
"    float rValue = BLOOM_FACTOR * (rDist * rDist) * (rSpread * rSpread);\n"
"    float byOpacity = min(1.0, rValue);\n"
"    return (byOpacity);\n"
"}\n"
"\n"
"float sampleNoiseFBM(vec3 sampler) {\n"
"    return texture(perlin_noise, vec3(sampler[0], sampler[1], sampler[2]))[0];\n"
"}\n"
"\n"
"float sampleNoiseFBMAnimated(vec3 sampler) {\n"
"    return texture(perlin_noise, vec3(sampler[0], sampler[1], sampler[2]))[2];\n"
"}\n"
"\n"
"float sampleNoisePerlin(vec3 sampler) {\n"
"    //return texture(perlin_noise, vec3(sampler[0], sampler[1], abs(mod(sampler[2], 2.0) - 1.0)))[1];\n"
"    return texture(perlin_noise, vec3(sampler[0], sampler[1], sampler[2]))[1];\n"
"}\n"
"\n"
"float fbm(vec2 a, float b) {\n"
"    return (sampleNoiseFBM(vec3(a.x, a.y, b)) * 2.0) - 1.0;\n"
"}\n"
"\n"
"float fbmAnimated(vec2 a, float b) {\n"
"    return (sampleNoiseFBMAnimated(vec3(a.x, a.y, b)) * 2.0) - 1.0;\n"
"}\n"
"\n"
"vec4 calcRayColor(float taperAdjTop, float taperAdjBottom, float widthAdjTop, float widthAdjBottom, float center_point, vec2 real_texcoord, float intensity, float distanceFromCenter, float grains, float opacityAdj, float widthCalcPos, float secondaryOpacity)\n"
"{\n"
"    float limitTop = taperAdjTop * widthAdjTop;\n"
"    float limitBottom = taperAdjBottom * widthAdjBottom;\n"
"\n"
"    // Note we don't use distanceFromCenter in pixelInUpper/LowerBounds since distanceFromCenter is abs, but we can't use abs there\n"
"    bool pixelInUpperBounds = ((real_texcoord[1] - center_point) < limitTop) && ((real_texcoord[1] - center_point) > 0);\n"
"    bool pixelInLowerBounds = ((real_texcoord[1] - center_point) > (-limitBottom)) && ((real_texcoord[1] - center_point) <= 0);\n"
"    float pixelWithinBounds = float(pixelInUpperBounds || pixelInLowerBounds);\n"
"	float topOpacityLengthwise = mix(1.0, secondaryOpacity / opacityAdj, widthCalcPos + 0.5) ;\n"
"	float bottomOpacityLengthwise = mix(1.0, secondaryOpacity / opacityAdj, widthCalcPos + 0.5);\n"
"    float topOpacityGlow = calcOpacityGlow(limitTop, intensity, distanceFromCenter);\n"
"    float bottomOpacityGlow = calcOpacityGlow(limitBottom, intensity, distanceFromCenter);\n"
"    float topOpacityTaperedGlow = calcOpacityTaperedGlow(limitTop, intensity, distanceFromCenter, real_texcoord[0]);\n"
"    float bottomOpacityTaperedGlow = calcOpacityTaperedGlow(limitBottom, intensity, distanceFromCenter, real_texcoord[0]);\n"
"    float topOpacityTaperedExponentialGlow = calcOpacityTaperedExponentialGlow(limitTop, intensity, distanceFromCenter, real_texcoord[0]);\n"
"    float bottomOpacityTaperedExponentialGlow = calcOpacityTaperedExponentialGlow(limitBottom, intensity, distanceFromCenter, real_texcoord[0]);\n"
"    float topOpacityFlareGlow = calcOpacityFlareGlow(distanceFromCenter, real_texcoord[0]);\n"
"    float bottomOpacityFlareGlow = calcOpacityFlareGlow(distanceFromCenter, real_texcoord[0]);\n"
"\n"
"    float topOpacity = (\n"
"        (topOpacityLengthwise * float(rayOpacity == opacityLengthwise)) +\n"
"        (topOpacityGlow * float(rayOpacity == opacityGlow)) +\n"
"        (topOpacityTaperedGlow * float(rayOpacity == opacityTaperedGlow)) +\n"
"        (topOpacityTaperedExponentialGlow * float(rayOpacity == opacityTaperedExponentialGlow)) +\n"
"        (topOpacityFlareGlow * float(rayOpacity == opacityFlareGlow))\n"
"    ) * opacityAdj;\n"
"    float bottomOpacity = (\n"
"        (bottomOpacityLengthwise * float(rayOpacity == opacityLengthwise)) +\n"
"        (bottomOpacityGlow * float(rayOpacity == opacityGlow)) +\n"
"        (bottomOpacityTaperedGlow * float(rayOpacity == opacityTaperedGlow)) +\n"
"        (bottomOpacityTaperedExponentialGlow * float(rayOpacity == opacityTaperedExponentialGlow)) +\n"
"        (bottomOpacityFlareGlow * float(rayOpacity == opacityFlareGlow))\n"
"    ) * opacityAdj;\n"
"    vec4 colorGlowTop = vec4(calcColorGlow(primaryColor, secondaryColor, limitTop, intensity, distanceFromCenter, widthCalcPos), topOpacity) * float(pixelInUpperBounds);\n"
"    vec4 colorGlowBottom = vec4(calcColorGlow(primaryColor, secondaryColor, limitBottom, intensity, distanceFromCenter, widthCalcPos), bottomOpacity) * float(pixelInLowerBounds);\n"
"	vec4 finalColor = (abs(colorGlowTop + colorGlowBottom) * grains);\n"
"	return finalColor;\n"
"}\n"
"\n"
"vec4 calcLightningColor(float taperAdj, float widthAdj, vec2 real_texcoord)\n"
"{\n"
"    return vec4(0.0); // We use Line for the lightning effect now even in OpenGL\n"
"	float wavefront_amplitude = 6.0f;\n"
"	float uv_x_lightning_mult = 10;\n"
"    float uv_y_mult = 4.0;\n"
"	vec2 uv = real_texcoord;\n"
"	uv.x *= uv_x_lightning_mult;\n"
"    uv.y *= uv_y_mult;\n"
"	float fbmscale = 1.0;\n"
"\n"
"    float wavefrontAdj = taperAdj * widthAdj;\n"
"\n"
"    float wavefront_pos = uv.y;\n"
"    float wavefront_multiplier = (rand(vec2(current_tick + abs(seed))) - 0.5) * wavefront_amplitude;\n"
"    wavefront_pos = uv.y + wavefront_multiplier * wavefrontAdj;\n"
"\n"
"    float endXReduction = clamp((uv.x * -uv.x * 0.1) + uv_x_lightning_mult * uv_x_lightning_mult * 0.1, 0.0f, 1.0f);\n"
"    uv.y *= 0;\n"
"    uv.x *= 0.8;\n"
"\n"
"    float noise = fbm((uv * 2 * fbmscale), (current_tick + seed) * (1.0 / 30.0) * fbmscale) * 2;\n"
"    float s1 = ((wavefront_pos) + (noise * endXReduction));\n"
"    float colorGrad = 1.0 / (s1 * (50.0));\n"
"	float alpha = abs(colorGrad * colorGrad);\n"
"	float quadPosAlphaAdj = (real_texcoord.x + 1) / 2;\n"
"	vec3 color = blendVectors(secondaryColor, primaryColor, quadPosAlphaAdj);\n"
"\n"
"	float epsilon = 0.01;\n"
"	bool alphaIsZero = alpha < epsilon;\n"
"	vec4 finalColor = vec4(color, pow(alpha, 0.1) * quadPosAlphaAdj * float(!alphaIsZero));\n"
"	return finalColor;\n"
"}\n"
"\n"
"vec4 calcRayLightningColor(vec2 quadSize, vec2 real_texcoord, float waveCyclePos, int grainyTexture, int reshape, int widthAdjType, float ray_center_x, float opacityAdj, float secondaryOpacity) {\n"
"    float distanceFromCenter = abs(real_texcoord[1] - ray_center_x);\n"
"\n"
"	// Graininess\n"
"    float grains_x = quadSize[0] / 20.0f;\n"
"    float grains_y = quadSize[1] / 20.0f;\n"
"    float perlinNoise = sampleNoisePerlin(vec3(quadPos[0] * grains_x * 0.1, quadPos[1] * grains_y * 0.1, current_tick * 100));\n"
"    float grains = (perlinNoise * float(grainyTexture == opacityGrainy) * 2) + float(grainyTexture == 0);\n"
"\n"
"	float widthCalcPos = real_texcoord[0];\n"
"\n"
"    float blobWidthTop = widthRandomWaves(widthCalcPos, BLOB_WAVE_SIZE, WAVY_WAVELENGTH_FACTOR * (quadSize[1] / quadSize[0]), 1.1);\n"
"    float blobWidthBottom = blobWidthTop;\n"
"    float jaggedWidthTop = widthRandomWaves(widthCalcPos, JAGGED_AMPLITUDE, JAGGED_WAVELENGTH_FACTOR * (quadSize[1] / quadSize[0]), 3.3);\n"
"    float jaggedWidthBottom = jaggedWidthTop;\n"
"    float whiptailWidthTop = widthWave(widthCalcPos, WHIPTAIL_AMPLITUDE, WHIPTAIL_WAVELENGTH_FACTOR * (quadSize[1] / quadSize[0]), WHIPTAIL_DECAY, waveCyclePos);\n"
"    float whiptailWidthBottom = widthWave(widthCalcPos, WHIPTAIL_AMPLITUDE, WHIPTAIL_WAVELENGTH_FACTOR * (quadSize[1] / quadSize[0]), WHIPTAIL_DECAY, waveCyclePos + 0.5);\n"
"    float taperWidth = widthTapered(widthCalcPos);\n"
"    float coneWidth = widthCone(widthCalcPos);\n"
"    float diamondWidth = widthDiamond(widthCalcPos);\n"
"    float ovalWidth = widthOval(widthCalcPos);\n"
"    float swordWidth = widthSword(widthCalcPos);\n"
"    float straightWidth = 1.0;\n"
"\n"
"    float taperAdjTop = (\n"
"        (straightWidth * float(reshape == widthAdjStraight)) +\n"
"        (blobWidthTop * float(reshape == widthAdjBlob)) +\n"
"        (diamondWidth * float(reshape == widthAdjDiamond)) +\n"
"        (coneWidth * float(reshape == widthAdjCone)) +\n"
"        (taperWidth * float(reshape == widthAdjTaper)) +\n"
"        (ovalWidth * float(reshape == widthAdjOval)) +\n"
"        (jaggedWidthTop * float(reshape == widthAdjJagged)) +\n"
"        (whiptailWidthTop * float(reshape == widthAdjWhiptail)) +\n"
"		(swordWidth * float(reshape == widthAdjSword))\n"
"    );\n"
"    float taperAdjBottom = (\n"
"        (straightWidth * float(reshape == widthAdjStraight)) +\n"
"        (blobWidthBottom * float(reshape == widthAdjBlob)) +\n"
"        (diamondWidth * float(reshape == widthAdjDiamond)) +\n"
"        (coneWidth * float(reshape == widthAdjCone)) +\n"
"        (taperWidth * float(reshape == widthAdjTaper)) +\n"
"        (ovalWidth * float(reshape == widthAdjOval)) +\n"
"        (jaggedWidthBottom * float(reshape == widthAdjJagged)) +\n"
"        (whiptailWidthBottom * float(reshape == widthAdjWhiptail)) +\n"
"		(swordWidth * float(reshape == widthAdjSword))\n"
"    );\n"
"\n"
"    float widthAdjTop = (\n"
"        (straightWidth * float(widthAdjType == widthAdjStraight)) +\n"
"        (blobWidthTop * float(widthAdjType == widthAdjBlob)) +\n"
"        (diamondWidth * float(widthAdjType == widthAdjDiamond)) +\n"
"        (coneWidth * float(widthAdjType == widthAdjCone)) +\n"
"        (taperWidth * float(widthAdjType == widthAdjTaper)) +\n"
"        (ovalWidth * float(widthAdjType == widthAdjOval)) +\n"
"        (jaggedWidthTop * float(widthAdjType == widthAdjJagged)) +\n"
"        (whiptailWidthTop * float(widthAdjType == widthAdjWhiptail)) +\n"
"		(swordWidth * float(widthAdjType == widthAdjSword))\n"
"    );\n"
"    float widthAdjBottom = (\n"
"        (straightWidth * float(widthAdjType == widthAdjStraight)) +\n"
"        (blobWidthBottom * float(widthAdjType == widthAdjBlob)) +\n"
"        (diamondWidth * float(widthAdjType == widthAdjDiamond)) +\n"
"        (coneWidth * float(widthAdjType == widthAdjCone)) +\n"
"        (taperWidth * float(widthAdjType == widthAdjTaper)) +\n"
"        (ovalWidth * float(widthAdjType == widthAdjOval)) +\n"
"        (jaggedWidthBottom * float(widthAdjType == widthAdjJagged)) +\n"
"        (whiptailWidthBottom * float(widthAdjType == widthAdjWhiptail)) +\n"
"		(swordWidth * float(widthAdjType == widthAdjSword))\n"
"    );\n"
"\n"
"	vec4 rayColor = calcRayColor(taperAdjTop, taperAdjBottom, widthAdjTop, widthAdjBottom, ray_center_x, real_texcoord, intensity, distanceFromCenter, grains, opacityAdj, widthCalcPos, secondaryOpacity);\n"
"	vec4 lightningColor = calcLightningColor(taperAdjTop, widthAdjTop, real_texcoord);\n"
"\n"
"\n"
"	vec4 finalColor = (\n"
"		rayColor * float(effectType == effectTypeRay) +\n"
"		lightningColor * float(effectType == effectTypeLightning)\n"
"	);\n"
"	finalColor[3] = max(finalColor[3], 0.0); // if finalColor[3] is nan, set it to zero\n"
"	return finalColor;\n"
"}\n"
"\n"
"// BEGIN ORB SUBSHADER\n"
"float pixelsDistanceFromCenter = length(quadPos) * (quadSize[0] / 2);\n"
"\n"
"const float SHELL_EDGE_WIDTH_RATIO = 0.05;\n"
"const float orb_fbm_time_divisor = 160.0;\n"
"const float orb_fbm_space_divisor = 55.0;\n"
"\n"
"// Copy of EAnimationTypes enum from SFXOrb.cpp\n"
"const int animateNone =           0;\n"
"const int animateDissipate =      1;\n"
"const int animateExplode =        2;\n"
"const int animateFade =           3;\n"
"const int animateFlicker =        4;\n"
"const int animateDim =            5;\n"
"\n"
"// Copy of EOrbStyles enum from SFXOrb.cpp\n"
"const int styleSmooth =           1;\n"
"const int styleFlare =            2;\n"
"const int styleCloud =            3;\n"
"const int styleFireblast =        4;\n"
"const int styleSmoke =            5;\n"
"const int styleDiffraction =      6;\n"
"const int styleFirecloud =        7;\n"
"const int styleBlackHole =        8;\n"
"const int styleLightning =        9;\n"
"const int styleShell =            10;\n"
"const int styleCloudshell =       11;\n"
"const int styleFireCloudshell =   12;\n"
"\n"
"const int styleGlowRing =		  -1;\n"
"\n"
"vec3 getExplosionColor(float fRadius, float fMaxRadius, float fIntensity, vec3 vPrimaryColor, vec3 vSecondaryColor) {\n"
"    const float SIGMA_MAX =                    0.01;\n"
"    const float SIGMA_DECAY =                  1.07;\n"
"    const float MAX_INTENSITY =                100.0;\n"
"\n"
"\n"
"    const float CORE_HEAT_LEVEL =              0.5;\n"
"    const float FRINGE_HEAT_LEVEL =            0.35;\n"
"    const float FRINGE_HEAT_RANGE =            (CORE_HEAT_LEVEL - FRINGE_HEAT_LEVEL);\n"
"    const float FLAME_HEAT_LEVEL =             0.25;\n"
"    const float FLAME_HEAT_RANGE =             (FRINGE_HEAT_LEVEL - FLAME_HEAT_LEVEL);\n"
"    const float MIN_HEAT_LEVEL =               0.1;\n"
"    const float MIN_HEAT_RANGE =               (FLAME_HEAT_LEVEL - MIN_HEAT_LEVEL);\n"
"\n"
"    float fHeatCalcIntensity = min(fIntensity, 100);\n"
"    float fHeatCountRadius = fRadius / fMaxRadius;\n"
"\n"
"    float fSigma2 = SIGMA_MAX * pow(SIGMA_DECAY, MAX_INTENSITY - fHeatCalcIntensity);\n"
"    float fSigma = sqrt(fSigma2);\n"
"    float fMaxX = sqrt(2) * sqrt(fSigma2 * log(1.0 / (fSigma * MIN_HEAT_LEVEL * sqrt(2 * 3.14159))));\n"
"    float fX = fMaxX * (fHeatCountRadius);\n"
"    float fHeat = (1.0 / (fSigma * sqrt(2 * 3.14159))) * exp((-fX * fX) / (2.0 * fSigma2));\n"
"\n"
"    bool useCoreColor = (fHeat > CORE_HEAT_LEVEL);\n"
"    vec3 coreColor = float(useCoreColor) * vec3(1.0);\n"
"\n"
"    bool useFringeColor = (fHeat > FRINGE_HEAT_LEVEL) && !useCoreColor;\n"
"    vec3 fringeColor = float(useFringeColor) * mix(vPrimaryColor, vec3(1.0), (fHeat - FRINGE_HEAT_LEVEL) / FRINGE_HEAT_RANGE);\n"
"\n"
"    bool useFlameColor = (fHeat > FLAME_HEAT_LEVEL) && !useFringeColor && !useCoreColor;\n"
"    vec3 flameColor = float(useFlameColor) * mix(vSecondaryColor, vPrimaryColor, pow((fHeat - FLAME_HEAT_LEVEL) * float(useFlameColor) / FLAME_HEAT_RANGE, 0.5));\n"
"\n"
"    bool useSecondaryColor = (!useCoreColor) && (!useFringeColor) && (!useFlameColor);\n"
"    vec3 secondaryColor = float(useSecondaryColor) * vSecondaryColor;\n"
"    //return vec3(fHeat);\n"
"    return coreColor + fringeColor + flameColor + secondaryColor;\n"
"}\n"
"\n"
"// ORB FUNCTIONS BEGIN HERE!\n"
"\n"
"vec4 calcSmoothColorBase(float fRadius, float fIntensity, vec3 vPrimaryColor, vec3 vSecondaryColor, float fOpacity, vec3 blownColor) {\n"
"    float fFringeMaxRadius = min(fRadius, fRadius * (fIntensity / 120.0));\n"
"    float fFringeWidth = fFringeMaxRadius / 8.0;\n"
"    float fBlownRadius = fFringeMaxRadius - fFringeWidth;\n"
"    float fFadeWidth = fRadius - fFringeMaxRadius;\n"
"\n"
"    // White within blown radius, 100% opacity\n"
"    bool useBlownRadius = (pixelsDistanceFromCenter < fBlownRadius);\n"
"    vec4 blownRadiusColor = float(useBlownRadius) * vec4(blownColor, fOpacity);\n"
"\n"
"    // Mix between primary color and white in fringe radius\n"
"    bool useFringeRadius = (pixelsDistanceFromCenter < fFringeMaxRadius && fFringeWidth > 0.0 && pixelsDistanceFromCenter >= fBlownRadius);\n"
"    float fringeOpacityStep = (pixelsDistanceFromCenter - fBlownRadius);\n"
"    float fringeOpacity = (fringeOpacityStep * fOpacity) / fFringeWidth;\n"
"    vec3 fringeRadiusColorRGB = mix(vec3(1.0, 1.0, 1.0), vec3(vPrimaryColor), fringeOpacity);\n"
"    vec4 fringeRadiusColor = float(useFringeRadius) * vec4(fringeRadiusColorRGB, fOpacity);\n"
"\n"
"\n"
"    // Secondary color in fade radius\n"
"    bool useFadeRadius = (pixelsDistanceFromCenter < (fFringeMaxRadius + fFadeWidth) && (pixelsDistanceFromCenter >= fFringeMaxRadius || fFringeWidth <= 0.0) && fFadeWidth > 0.0);\n"
"    float fadeOpacityStep = (pixelsDistanceFromCenter - fFringeMaxRadius);\n"
"    float fadeOpacity = 1.0 - (fadeOpacityStep / fFadeWidth);\n"
"    fadeOpacity = (fadeOpacity * fadeOpacity) * fOpacity;\n"
"    vec4 fadeRadiusColor = float(useFadeRadius) * vec4(vSecondaryColor, fadeOpacity);\n"
"\n"
"    // Black otherwise\n"
"    bool useBlackRadius = (pixelsDistanceFromCenter > fRadius) || (pixelsDistanceFromCenter >= (fFringeMaxRadius + fFadeWidth));\n"
"    vec4 blackRadiusColor = float(useBlackRadius) * vec4(0.0);\n"
"\n"
"    return (blownRadiusColor + fringeRadiusColor + fadeRadiusColor + blackRadiusColor);\n"
"}\n"
"\n"
"float FloatIncrementor(float start, float power, float limit, float end, float inputValue) {\n"
"    float range = end - start;\n"
"    float currStep = inputValue / limit;\n"
"    return (start + pow(currStep, power) * range);\n"
"}\n"
"\n"
"float CalcShellOpacity(float fRadius, float fIntensity, float fOpacity) {\n"
"/*\n"
"    ASSERT(iRadius >= 0);\n"
"    ASSERT(iShellMaxRadius >= 0);\n"
"\n"
"    iIntensity = Max(0, Min(iIntensity, 100));\n"
"    iShellMaxRadius = Min(iShellMaxRadius, iRadius);\n"
"    int iEdgeWidth = iRadius - iShellMaxRadius;\n"
"\n"
"    if (retOpacity.GetCount() < iRadius)\n"
"        retOpacity.InsertEmpty(iRadius - retOpacity.GetCount());\n"
"\n"
"    CStepIncrementor MaxIntensity(CStepIncrementor::styleOct, 0.0, 1.0, iShellMaxRadius);\n"
"    CStepIncrementor MinIntensity(CStepIncrementor::styleLinear, 0.0, 1.0, iShellMaxRadius);\n"
"    Metric rMaxIntensityK = iIntensity / 100.0;\n"
"    Metric rMinIntensityK = (100 - iIntensity) / 100.0;\n"
"\n"
"    for (int i = 0; i < iShellMaxRadius; i++)\n"
"        retOpacity[i] = (BYTE)(byOpacity * ((MaxIntensity.GetAt(i) * rMaxIntensityK) + (MinIntensity.GetAt(i) * rMinIntensityK)));\n"
"\n"
"    CStepIncrementor Fade(CStepIncrementor::styleSquare, 1.0, 0.0, iEdgeWidth + 1);\n"
"    for (int i = 0; i < iEdgeWidth; i++)\n"
"        retOpacity[iShellMaxRadius + i] = (BYTE)(byOpacity * Fade.GetAt(1 + i));\n"
"    */\n"
"    float fEdgeWidthForMaxRadius = fRadius * SHELL_EDGE_WIDTH_RATIO;\n"
"    float fShellMaxRadius = fRadius - fEdgeWidthForMaxRadius;\n"
"\n"
"    float fCappedIntensity = max(0.0, min(fIntensity, 100.0));\n"
"    fShellMaxRadius = min(fShellMaxRadius, fRadius);\n"
"    float fEdgeWidth = fRadius - fShellMaxRadius;\n"
"\n"
"    float fMaxIntensity = FloatIncrementor(0.0, 8.0, fShellMaxRadius, 1.0, pixelsDistanceFromCenter);\n"
"    float fMinIntensity = FloatIncrementor(0.0, 1.0, fShellMaxRadius, 1.0, pixelsDistanceFromCenter);\n"
"    float fMaxIntensityK = fIntensity / 100.0;\n"
"    float fMinIntensityK = (100 - fIntensity) / 100.0;\n"
"    float fFade = FloatIncrementor(1.0, 2.0, fEdgeWidth + 1.0, 0.0, (1.0 + pixelsDistanceFromCenter) - fShellMaxRadius);\n"
"\n"
"    bool useInnerOpacity = pixelsDistanceFromCenter < fShellMaxRadius;\n"
"    float innerOpacity = fOpacity * ((fMaxIntensity * fMaxIntensityK) + (fMinIntensity * fMinIntensityK)) * float(useInnerOpacity);\n"
"    bool useOuterOpacity = (pixelsDistanceFromCenter >= fShellMaxRadius) && (pixelsDistanceFromCenter < fRadius);\n"
"    float outerOpacity = fOpacity * fFade * float(useOuterOpacity);\n"
"    return innerOpacity + outerOpacity;\n"
"}\n"
"\n"
"vec4 calcShellColor(float fRadius, float fIntensity, vec3 vPrimaryColor, vec3 vSecondaryColor, float fShellOpacity) {\n"
"/*\n"
"    ASSERT(iRadius >= 0);\n"
"\n"
"    if (retColorTable->GetCount() < iRadius)\n"
"        retColorTable->InsertEmpty(iRadius - retColorTable->GetCount());\n"
"\n"
"    int iEdgeWidth = mathRound(iRadius * SHELL_EDGE_WIDTH_RATIO);\n"
"    int iShellMaxRadius = iRadius - iEdgeWidth;\n"
"    int iHoleRadius = iShellMaxRadius * iIntensity / 120;\n"
"\n"
"    TArray<BYTE> OpacityRamp;\n"
"    CalcShellOpacity(iRadius, iShellMaxRadius, iIntensity, byOpacity, OpacityRamp);\n"
"\n"
"    //  Initialize table\n"
"\n"
"    for (int i = 0; i < iRadius; i++)\n"
"        {\n"
"        if (i < iHoleRadius)\n"
"            (*retColorTable)[i] = CG32bitPixel(rgbSecondary, OpacityRamp[i]);\n"
"\n"
"        else if (i < iShellMaxRadius)\n"
"            {\n"
"            int iStep = (i - iHoleRadius);\n"
"            DWORD dwBlend = 255 * iStep / (iShellMaxRadius - iHoleRadius);\n"
"            (*retColorTable)[i] = CG32bitPixel(CG32bitPixel::Blend(rgbSecondary, rgbPrimary, (BYTE)dwBlend), OpacityRamp[i]);\n"
"            }\n"
"        else\n"
"            (*retColorTable)[i] = CG32bitPixel(rgbPrimary, OpacityRamp[i]);\n"
"        }\n"
"    }\n"
"    */\n"
"    float fEdgeWidth = fRadius * SHELL_EDGE_WIDTH_RATIO;\n"
"    float fShellMaxRadius = fRadius - fEdgeWidth;\n"
"    float fHoleRadius = fShellMaxRadius * fIntensity / 120;\n"
"\n"
"    bool useHoleColor = (pixelsDistanceFromCenter < fHoleRadius);\n"
"    vec4 holeColor = float(useHoleColor) * vec4(vSecondaryColor, fShellOpacity);\n"
"\n"
"    bool useShellColor = (!useHoleColor) && (pixelsDistanceFromCenter < fShellMaxRadius);\n"
"    float blend = (pixelsDistanceFromCenter - fHoleRadius) / (fShellMaxRadius - fHoleRadius);\n"
"    vec4 shellColor = float(useShellColor) * vec4(mix(vSecondaryColor, vPrimaryColor, blend), fShellOpacity);\n"
"\n"
"    bool useOuterColor = (!useHoleColor) && (!useShellColor);\n"
"    vec4 outerColor = float(useOuterColor) * vec4(vPrimaryColor, fShellOpacity);\n"
"\n"
"    return holeColor + shellColor + outerColor;\n"
"}\n"
"\n"
"vec4 calcSmoothColor(float fRadius, float fIntensity, vec3 vPrimaryColor, vec3 vSecondaryColor, float fOpacity) {\n"
"    return calcSmoothColorBase(fRadius, fIntensity, vPrimaryColor, vSecondaryColor, fOpacity, vec3(1.0, 1.0, 1.0));\n"
"}\n"
"\n"
"vec4 calcBlackHoleColor(float fRadius, float fIntensity, vec3 vPrimaryColor, vec3 vSecondaryColor, float fOpacity) {\n"
"    return calcSmoothColorBase(fRadius, fIntensity, vPrimaryColor, vSecondaryColor, fOpacity, vec3(0.0, 0.0, 0.0));\n"
"}\n"
"\n"
"vec4 calcFlareColor(float fRadius, float fIntensity, vec3 vPrimaryColor, vec3 vSecondaryColor, float fOpacity) {\n"
"    vec3 centerColor = mix(vPrimaryColor, vec3(1.0, 1.0, 1.0), fIntensity / 100.0);\n"
"    vec3 edgeColor = vSecondaryColor;\n"
"    float fFade = pixelsDistanceFromCenter / fRadius;\n"
"    vec3 rgbColor = mix(centerColor, edgeColor, fFade);\n"
"    float alpha = max(0.0, fOpacity - ((pixelsDistanceFromCenter * fOpacity) / fRadius));\n"
"    return vec4(rgbColor, alpha);\n"
"}\n"
"\n"
"vec4 calcDiffractionColor(float fRadius, float fIntensity, vec3 vPrimaryColor, vec3 vSecondaryColor, float fOpacity, vec4 flareColor) {\n"
"    float ring_pixel_distance = 2.0;\n"
"    float modVal = mod(pixelsDistanceFromCenter, ring_pixel_distance);\n"
"    float useEvenColor = abs(modVal - (ring_pixel_distance / 2.0)) / (ring_pixel_distance / 2.0);\n"
"    vec3 evenColor = mix(vec3(0.0, 0.0, 0.0), vec3(flareColor), 0.5);\n"
"    vec3 oddColor = mix(vec3(flareColor), vec3(1.0, 1.0, 1.0), 0.5);\n"
"    vec4 fColor = vec4(mix(oddColor, evenColor, useEvenColor), flareColor[3]);\n"
"    return fColor;\n"
"}\n"
"\n"
"vec4 calcCloudRadialColor(float fRadius, float fIntensity, vec3 vPrimaryColor, vec3 vSecondaryColor, float fOpacity) {\n"
"    float cloudOpacity = FloatIncrementor(fOpacity, 2.0, fRadius, 0.0, pixelsDistanceFromCenter);\n"
"    return vec4(1.0, 1.0, 1.0, cloudOpacity);\n"
"}\n"
"\n"
"vec4 calcCloudShellRadialColor(float fRadius, float fIntensity, vec3 vPrimaryColor, vec3 vSecondaryColor, float fOpacity) {\n"
"    return vec4(1.0, 1.0, 1.0, fOpacity);\n"
"}\n"
"\n"
"vec4 calcSmokeRadialColor(float fRadius, float fIntensity, vec3 vPrimaryColor, vec3 vSecondaryColor, float fOpacity) {\n"
"    float fOpacityValue = FloatIncrementor(fOpacity, 4.0, fRadius, 0.0, pixelsDistanceFromCenter);\n"
"    float fCenterAdj = FloatIncrementor(max(0.0, (70.0 - fIntensity)) / 100.0, 2.0, fRadius, 1.0, pixelsDistanceFromCenter);\n"
"    return vec4(mix(vPrimaryColor, vSecondaryColor, pixelsDistanceFromCenter / fRadius), fCenterAdj * fOpacityValue);\n"
"}\n"
"\n"
"vec4 calcCloudPixelColor(float fRadius, float fIntensity, float fLookupValue, vec3 vPrimaryColor, vec3 vSecondaryColor, float fOpacity) {\n"
"    float fHighAdj = fOpacity;\n"
"    float fLowAdj = 1.0 - fHighAdj;\n"
"\n"
"    float newOpacity = fHighAdj + (fLookupValue * fLowAdj);\n"
"    return vec4(mix(vSecondaryColor, vPrimaryColor, fLookupValue), newOpacity);\n"
"}\n"
"\n"
"vec4 calcCloudColor(vec4 radialColor, vec4 pixelColor) {\n"
"    return vec4(pixelColor[0], pixelColor[1], pixelColor[2], pixelColor[3] * radialColor[3]);\n"
"}\n"
"\n"
"vec4 calcFirecloudPixelColor(float fRadius, float fIntensity, float fLookupValue, vec3 vPrimaryColor, vec3 vSecondaryColor, float fOpacity) {\n"
"    float fHighAdj = fOpacity;\n"
"    float fLowAdj = 1.0 - fHighAdj;\n"
"\n"
"    float newOpacity = fHighAdj + (fLookupValue * fLowAdj);\n"
"    return vec4(getExplosionColor(fLookupValue, 1.0, fIntensity, vPrimaryColor, vSecondaryColor), newOpacity);\n"
"}\n"
"\n"
"vec4 calcFireblastRadialColor(float fRadius, float fIntensity, float queryRadius, vec3 vPrimaryColor, vec3 vSecondaryColor, float fOpacity) {\n"
"    float BLOWN_INTENSITY = 95.0;\n"
"    float BLOWN_SIZE = 100.0 - BLOWN_INTENSITY;\n"
"    float FIRE_INTENSITY = 80.0;\n"
"    float FIRE_SIZE = BLOWN_INTENSITY - FIRE_INTENSITY;\n"
"    float GLOW_INTENSITY = 25.0;\n"
"    float GLOW_SIZE = FIRE_INTENSITY - GLOW_INTENSITY;\n"
"    float FADE_INTENSITY = 0.0;\n"
"    float FADE_SIZE = GLOW_INTENSITY - FADE_INTENSITY;\n"
"    //CStepIncrementor Opacity(CStepIncrementor::styleSquare, byOpacity, 0.0, iRadius);\n"
"    FloatIncrementor(fOpacity, 2.0, fRadius, 0.0, pixelsDistanceFromCenter);\n"
"\n"
"    float fOpacityInc = FloatIncrementor(fOpacity, 8.0, fRadius, 0.0, queryRadius);\n"
"    float fRadiusInc = FloatIncrementor(0.0, 4.0, fRadius, 1.0, queryRadius);\n"
"\n"
"    bool useBlown = (fIntensity > BLOWN_INTENSITY);\n"
"    float fBlownFade = min(FloatIncrementor(100.0, 8.0, BLOWN_SIZE, 0.0, fIntensity - BLOWN_INTENSITY), 100.0);\n"
"    vec3 fColCenterBlown = mix(vec3(1.0), vPrimaryColor, fBlownFade / 100.0) * float(useBlown);\n"
"    vec3 fColEdgeBlown = mix(vec3(1.0), vPrimaryColor, fBlownFade / 100.0) * float(useBlown);\n"
"\n"
"    bool useFire = (fIntensity > FIRE_INTENSITY) && !useBlown;\n"
"    float fFireFade = min(FloatIncrementor(100.0, 8.0, FIRE_SIZE, 0.0, fIntensity - FIRE_INTENSITY), 100.0);\n"
"    vec3 fColCenterFire = vPrimaryColor * float(useFire);\n"
"    vec3 fColEdgeFire = mix(vPrimaryColor, vSecondaryColor, fFireFade / 100.0) * float(useFire);\n"
"\n"
"    bool useGlow = (fIntensity > GLOW_INTENSITY) && !useFire && !useBlown;\n"
"    float fGlowFade = min(FloatIncrementor(100.0, 8.0, GLOW_SIZE, 0.0, fIntensity - GLOW_INTENSITY), 100.0);\n"
"    vec3 fColCenterGlow = mix(vPrimaryColor, vSecondaryColor, fGlowFade / 100.0) * float(useGlow);\n"
"    vec3 fColEdgeGlow = vSecondaryColor * float(useGlow);\n"
"\n"
"    bool useFade = (fIntensity > FADE_INTENSITY) && !useGlow && !useFire && !useBlown;\n"
"    float fFadeFade = min(FloatIncrementor(100.0, 8.0, FADE_SIZE, 0.0, fIntensity - FADE_INTENSITY), 100.0);\n"
"    vec3 fColCenterFade = vSecondaryColor * float(useFade);\n"
"    vec3 fColEdgeFade = mix(vSecondaryColor, vec3(0.0), fFadeFade / 100.0) * float(useFade);\n"
"\n"
"    vec3 fColCenter = fColCenterBlown + fColCenterFire + fColCenterGlow + fColCenterFade;\n"
"    vec3 fColEdge = fColEdgeBlown + fColEdgeFire + fColEdgeGlow + fColEdgeFade;\n"
"\n"
"    //return vec4(vec3(fColCenterGlow), 1.0);\n"
"    return vec4(mix(fColCenter, fColEdge, fRadiusInc), fOpacityInc);\n"
"}\n"
"\n"
"vec4 calcFireblastPixelColor(float fRadius, float fIntensity, float queryRadius, vec3 vPrimaryColor, vec3 vSecondaryColor, float fOpacity) {\n"
"    float fIntensityInc = min(FloatIncrementor(100.0, 2.0, 100.0, 0.0, fIntensity), 100.0);\n"
"    float fOpacityInc = FloatIncrementor(fOpacity, 1.0, fRadius, 0.0, queryRadius);\n"
"    float fRadiusInc = FloatIncrementor(0.0, 1.0 / 8.0, fRadius, 1.0, queryRadius);\n"
"\n"
"    vec3 fColCenter = mix(vPrimaryColor, vSecondaryColor, fIntensityInc / 100.0);\n"
"    vec3 fColEdge = mix(vSecondaryColor, vec3(0.0), fIntensityInc / 100.0);\n"
"\n"
"    return vec4(mix(fColCenter, fColEdge, fRadiusInc), fOpacityInc);\n"
"}\n"
"\n"
"vec4 calcFireblastColor(float fRadius, float fIntensity, vec3 vPrimaryColor, vec3 vSecondaryColor, float fOpacity) {\n"
"    // Adjust radius between 1.0 times radius and (1.0 + disrupt) times radius\n"
"    float ANGLE_DISTORTION_MULTIPLIER = 0.4;\n"
"    // TODO: Add a seed!\n"
"    float angle_phase_adj = seed * 3;\n"
"    float rand_noise_seed = seed * 1;\n"
"    //float fAngle = (dot(quadPos, vec2(0.0, 1.0)) / length(quadPos));\n"
"    float fAngle = abs(mod(atan(quadPos.y, quadPos.x) + angle_phase_adj, (3.14159 * 2)) - 3.14159);//(dot(quadPos, vec2(0.0, 1.0)) / length(quadPos));\n"
"    float fRand = ((sampleNoisePerlin(vec3(fAngle * ANGLE_DISTORTION_MULTIPLIER + rand_noise_seed)) / 2.0) + 0.5);\n"
"    float fRadAdjFactor = (1 + (fRand * float(orbDistortion) / 100.0));\n"
"    vec2 fAdjPos = quadPos * fRadAdjFactor;\n"
"    float fAdjRadius = pixelsDistanceFromCenter * fRadAdjFactor;\n"
"    //float fAdjRadius = pixelsDistanceFromCenter;\n"
"    bool useBlack = (fAdjRadius >= fRadius);\n"
"\n"
"    float fNoiseValue = fbmAnimated((fAdjPos + 1.0) / orb_fbm_space_divisor, current_tick / orb_fbm_time_divisor) + 0.5;\n"
"\n"
"    vec4 fireblastPixelColor = calcFireblastPixelColor(fRadius, fIntensity, fAdjRadius, vPrimaryColor, vSecondaryColor, fOpacity);\n"
"    vec4 fireblastRadialColor = calcFireblastRadialColor(fRadius, fIntensity, fAdjRadius, vPrimaryColor, vSecondaryColor, fOpacity);\n"
"\n"
"    //return vec4(fAdjRadius) / 300;\n"
"    return mix(fireblastRadialColor, fireblastPixelColor, fNoiseValue) * float(!useBlack);\n"
"}\n"
"\n"
"\n"
"vec4 calcGlowRingColor(float fRadius, float fIntensity, vec3 vPrimaryColor, vec3 vSecondaryColor, float fOpacity) {\n"
"    // For glow rings, fIntensity is equal to 1/2 the glow width as a fraction of fRadius, primaryColor is the solid color, and secondaryColor is the edge color.\n"
"	// secondaryOpacity is the edge opacity, and fOpacity is the solid opacity.\n"
"	// GlowRings should always be rendered as "None" animation type.\n"
"    // Adjust radius between 1.0 times radius and (1.0 + disrupt) times radius\n"
"\n"
"	float ringWidthInPixels = max(1.0, fIntensity * (quadSize[0] / 2)) / 2.0;\n"
"	float ringMiddle = fRadius - ringWidthInPixels;\n"
"\n"
"	bool useOuterRamp = pixelsDistanceFromCenter >= ringMiddle && pixelsDistanceFromCenter <= fRadius;\n"
"	bool useInnerRamp = pixelsDistanceFromCenter < ringMiddle && pixelsDistanceFromCenter >= (ringMiddle - ringWidthInPixels);\n"
"\n"
"	float distanceFromRingMiddle = min(abs(pixelsDistanceFromCenter - ringMiddle) / ringWidthInPixels, 1.0);\n"
"\n"
"	vec4 center = vec4(vPrimaryColor, fOpacity);\n"
"	vec4 edge = vec4(vSecondaryColor, orbSecondaryOpacity);\n"
"	vec4 finalColorRaw = mix(center, edge, distanceFromRingMiddle) * float(useOuterRamp || useInnerRamp);\\n"
"	vec3 finalColorRGB = vec3(finalColorRaw[0], finalColorRaw[1], finalColorRaw[2]);\n"
"	vec4 finalColorPreMult = vec4(finalColorRGB * finalColorRaw[3], finalColorRaw[3]);\n"
"	return finalColorRaw;\n"
"}\n"
"\n"
"vec4 calcPrimaryColor(int iStyle, float fRadius, float fIntensity, vec3 vPrimaryColor, vec3 vSecondaryColor, float fOpacity, float noise) {\n"
"    // Switch for styles.\n"
"    // This is analogous to CalcSphericalColorTable in georgecode.\n"
"    float shellOpacity = CalcShellOpacity(fRadius, fIntensity, fOpacity); // used for shell, cloudshell\n"
"    vec4 cloudRadialColor = calcCloudRadialColor(fRadius, fIntensity, vPrimaryColor, vSecondaryColor, fOpacity); // used for cloud, firecloud\n"
"    vec4 cloudShellRadialColor = calcCloudShellRadialColor(fRadius, fIntensity, vPrimaryColor, vSecondaryColor, shellOpacity); // used for cloudshell\n"
"    vec4 smokeRadialColor = calcSmokeRadialColor(fRadius, fIntensity, vPrimaryColor, vSecondaryColor, fOpacity); // used for smoke\n"
"//    vec4 fireblastRadialColor = calcFireblastRadialColor(fRadius, fIntensity, vPrimaryColor, vSecondaryColor, fOpacity); // used for smoke\n"
"    vec4 cloudPixelColor = calcCloudPixelColor(fRadius, fIntensity, noise, vPrimaryColor, vSecondaryColor, fOpacity); // used for cloud, cloudshell, smoke\n"
"    vec4 firecloudPixelColor = calcFirecloudPixelColor(fRadius, fIntensity, noise, vPrimaryColor, vSecondaryColor, fOpacity); // used for firecloud\n"
"    vec4 fireblastColor = calcFireblastColor(fRadius, fIntensity, vPrimaryColor, vSecondaryColor, fOpacity); // used for firecloud\n"
"    vec4 glowRingColor = calcGlowRingColor(fRadius, fIntensity, vPrimaryColor, vSecondaryColor, fOpacity); // used for firecloud\n"
"\n"
"    vec4 cloudColor = calcCloudColor(cloudRadialColor, cloudPixelColor);\n"
"    vec4 firecloudColor = calcCloudColor(cloudRadialColor, firecloudPixelColor);\n"
"    vec4 fireCloudshellColor = calcCloudColor(cloudShellRadialColor, firecloudPixelColor);\n"
"    vec4 cloudShellColor = calcCloudColor(cloudShellRadialColor, cloudPixelColor);\n"
"    vec4 smokeColor = calcCloudColor(smokeRadialColor, cloudPixelColor);\n"
"\n"
"    vec4 smoothColor = calcSmoothColor(fRadius, fIntensity, vPrimaryColor, vSecondaryColor, fOpacity);\n"
"    vec4 blackHoleColor = calcBlackHoleColor(fRadius, fIntensity, vPrimaryColor, vSecondaryColor, fOpacity);\n"
"    vec4 shellColor = calcShellColor(fRadius, fIntensity, vPrimaryColor, vSecondaryColor, shellOpacity);\n"
"    vec4 flareColor = calcFlareColor(fRadius, fIntensity, vPrimaryColor, vSecondaryColor, fOpacity);\n"
"    vec4 diffractionColor = calcDiffractionColor(fRadius, fIntensity, vPrimaryColor, vSecondaryColor, fOpacity, flareColor);\n"
"\n"
"    vec4 finalColor = (\n"
"        (cloudColor * float(orbStyle == styleCloud)) +\n"
"        (firecloudColor * float(orbStyle == styleFirecloud)) +\n"
"        (fireCloudshellColor * float(orbStyle == styleFireCloudshell)) +\n"
"        (smokeColor * float(orbStyle == styleSmoke)) +\n"
"        (smoothColor * float(orbStyle == styleSmooth)) +\n"
"        (fireblastColor * float(orbStyle == styleFireblast)) +\n"
"        (blackHoleColor * float(orbStyle == styleBlackHole)) +\n"
"        (shellColor * float(orbStyle == styleShell)) +\n"
"        (flareColor * float(orbStyle == styleFlare)) +\n"
"        (diffractionColor * float(orbStyle == styleDiffraction)) +\n"
"        (cloudShellColor * float(orbStyle == styleCloudshell)) +\n"
"        (flareColor * float(orbStyle == styleLightning)) +\n"
"        (glowRingColor * float(orbStyle == styleGlowRing))\n"
"\n"
"    );\n"
"    return (finalColor);\n"
"}\n"
"\n"
"float calcAnimateExplodeSecondaryOpacity(float fRadius, float fOpacity, float fFrame) {\n"
"    float fEndFade = float(orbLifetime) / 3.0;\n"
"    float fEndFadeStart = float(orbLifetime) - fEndFade;\n"
"\n"
"    float useEndFadeStart = float(fFrame > fEndFadeStart);\n"
"    float fFadeOpacity = useEndFadeStart * (fEndFade - (fFrame - fEndFadeStart)) / fEndFade;\n"
"\n"
"    float useOpacity = float(fFrame <= fEndFadeStart);\n"
"\n"
"    return (fFadeOpacity * useEndFadeStart) + (fOpacity * useOpacity);\n"
"\n"
"}\n"
"\n"
"vec4 calcAnimationColor(float animatedNoise, float scaledNoise, float orbRadius) {\n"
"    // Obtain the following attributes for the sphere color calculation:\n"
"    // m_iStyle, m_iRadius, m_iIntensity, m_rgbPrimaryColor, m_rgbSecondaryColor, m_byOpacity.\n"
"    // Note that orbStyle, secondaryColor are not changed by animation orbStyle.\n"
"        //CStepIncrementor Opacity(CStepIncrementor::styleSquare, byOpacity, 0.0, iRadius);\n"
"        //FloatIncrementor(fOpacity, 2.0, fRadius, 0.0, pixelsDistanceFromCenter);\n"
"    float fLifetime = float(orbLifetime);\n"
"    float fCurrframe = float(orbCurrFrame);\n"
"    float animateDissipateRadius = FloatIncrementor(0.2 * orbRadius, 0.5, fLifetime, orbRadius, fCurrframe);\n"
"    float animateDissipateIntensity = FloatIncrementor(intensity, 1.0, fLifetime, 0.0, fCurrframe);\n"
"    float animateDissipateDetail = FloatIncrementor(float(orbDetail) / 100.0f, 1.0, fLifetime, float(orbDetail) / 1000.0f, fCurrframe);\n"
"    float animateDissipateColorFade = FloatIncrementor(0.0, 1.0, fLifetime, 1.0, fCurrframe);\n"
"\n"
"    vec3 animateDissipatePrimaryColor = mix(primaryColor, secondaryColor, animateDissipateColorFade);\n"
"    float animateDissipateNoise = scaledNoise;\n"
"    float animateDissipateOpacity = opacityAdj;\n"
"    float animateDissipateSecondaryOpacity = orbSecondaryOpacity;\n"
"\n"
"    float animateExplodeRadius = animateDissipateRadius;\n"
"    float animateExplodeDetail = animateDissipateDetail;\n"
"    float animateExplodeHeat = FloatIncrementor(100.0, 2.0, fLifetime, 0.0, fCurrframe);\n"
"	float animateExplodeIntensity = animateExplodeHeat;\n"
"\n"
"    vec3 animateExplodePrimaryColor = primaryColor;\n"
"    float animateExplodeNoise = scaledNoise;\n"
"    float animateExplodeOpacity = calcAnimateExplodeSecondaryOpacity(orbRadius, opacityAdj, fCurrframe);\n"
"    float animateExplodeSecondaryOpacity = animateExplodeOpacity;\n"
"\n"
"    float animateFadeProgress = (fLifetime - fCurrframe) / fLifetime;\n"
"    float animateFadeRadius = orbRadius * animateFadeProgress;\n"
"    float animateFadeIntensity = intensity * animateFadeProgress;\n"
"    float animateFadeDetail = animateDissipateDetail;\n"
"\n"
"    vec3 animateFadePrimaryColor = primaryColor;\n"
"    float animateFadeNoise = scaledNoise;\n"
"    float animateFadeOpacity = opacityAdj;\n"
"    float animateFadeSecondaryOpacity = orbSecondaryOpacity;\n"
"\n"
"	// Note that for flicker we just use the orb radius and intensity we're given. This is because those variables are\n"
"	// supplied on the CPU end, so we can sync the flickering and flare effects.\n"
"    float animateFlickerRadius = orbRadius;\n"
"    float animateFlickerIntensity = intensity;\n"
"    animateFlickerIntensity = (float(orbStyle == styleFireblast) * (min(max(animateFlickerIntensity, 0.0), 100.0))) + (float(orbStyle != styleFireblast) * animateFlickerIntensity);\n"
"    vec3 animateFlickerPrimaryColor = primaryColor;\n"
"    float animateFlickerDetail = orbDetail;\n"
"    float animateFlickerNoise = scaledNoise;\n"
"    float animateFlickerOpacity = opacityAdj;\n"
"    float animateFlickerSecondaryOpacity = orbSecondaryOpacity;\n"
"\n"
"    float animateDimRadius = orbRadius;\n"
"    float animateDimIntensity = intensity;\n"
"    vec3 animateDimPrimaryColor = mix(primaryColor, secondaryColor, FloatIncrementor(0.0, 1.0, fLifetime, 1.0, fCurrframe));\n"
"    float animateDimDetail = orbDetail;\n"
"    float animateDimNoise = scaledNoise;\n"
"    float animateDimOpacity = FloatIncrementor(opacityAdj, 1.0, fLifetime, orbSecondaryOpacity, fCurrframe);\n"
"    float animateDimSecondaryOpacity = orbSecondaryOpacity;\n"
"\n"
"    float animateNoneRadius = orbRadius;\n"
"    float animateNoneIntensity = intensity;\n"
"    vec3 animateNonePrimaryColor = primaryColor;\n"
"    float animateNoneDetail = orbDetail;\n"
"    float animateNoneNoise = scaledNoise;\n"
"    float animateNoneOpacity = opacityAdj;\n"
"    float animateNoneSecondaryOpacity = orbSecondaryOpacity;\n"
"\n"
"    float finalRadius = (\n"
"        (animateNoneRadius * float(orbAnimation == animateNone)) +\n"
"        (animateDissipateRadius * float(orbAnimation == animateDissipate)) +\n"
"        (animateExplodeRadius * float(orbAnimation == animateExplode)) +\n"
"        (animateFadeRadius * float(orbAnimation == animateFade)) +\n"
"        (animateFlickerRadius * float(orbAnimation == animateFlicker)) +\n"
"        (animateDimRadius * float(orbAnimation == animateDim))\n"
"    );\n"
"\n"
"    float finalIntensity = (\n"
"        (animateNoneIntensity * float(orbAnimation == animateNone)) +\n"
"        (animateDissipateIntensity * float(orbAnimation == animateDissipate)) +\n"
"        (animateExplodeIntensity * float(orbAnimation == animateExplode)) +\n"
"        (animateFadeIntensity * float(orbAnimation == animateFade)) +\n"
"        (animateFlickerIntensity * float(orbAnimation == animateFlicker)) +\n"
"        (animateDimIntensity * float(orbAnimation == animateDim))\n"
"    );\n"
"\n"
"    float finalDetail = (\n"
"        (animateNoneDetail * float(orbAnimation == animateNone)) +\n"
"        (animateDissipateDetail * float(orbAnimation == animateDissipate)) +\n"
"        (animateExplodeDetail * float(orbAnimation == animateExplode)) +\n"
"        (animateFadeDetail * float(orbAnimation == animateFade)) +\n"
"        (animateFlickerDetail * float(orbAnimation == animateFlicker)) +\n"
"        (animateDimDetail * float(orbAnimation == animateDim))\n"
"    );\n"
"\n"
"    vec3 finalPrimaryColor = (\n"
"        (animateNonePrimaryColor * float(orbAnimation == animateNone)) +\n"
"        (animateDissipatePrimaryColor * float(orbAnimation == animateDissipate)) +\n"
"        (animateExplodePrimaryColor * float(orbAnimation == animateExplode)) +\n"
"        (animateFadePrimaryColor * float(orbAnimation == animateFade)) +\n"
"        (animateFlickerPrimaryColor * float(orbAnimation == animateFlicker)) +\n"
"        (animateDimPrimaryColor * float(orbAnimation == animateDim))\n"
"    );\n"
"\n"
"    float finalNoise = (\n"
"        (animateNoneNoise * float(orbAnimation == animateNone)) +\n"
"        (animateDissipateNoise * float(orbAnimation == animateDissipate)) +\n"
"        (animateExplodeNoise * float(orbAnimation == animateExplode)) +\n"
"        (animateFadeNoise * float(orbAnimation == animateFade)) +\n"
"        (animateFlickerNoise * float(orbAnimation == animateFlicker)) +\n"
"        (animateDimNoise * float(orbAnimation == animateDim))\n"
"    );\n"
"\n"
"    float finalOpacity = (\n"
"        (animateNoneOpacity * float(orbAnimation == animateNone)) +\n"
"        (animateDissipateOpacity * float(orbAnimation == animateDissipate)) +\n"
"        (animateExplodeOpacity * float(orbAnimation == animateExplode)) +\n"
"        (animateFadeOpacity * float(orbAnimation == animateFade)) +\n"
"        (animateFlickerOpacity * float(orbAnimation == animateFlicker)) +\n"
"        (animateDimOpacity * float(orbAnimation == animateDim))\n"
"    );\n"
"\n"
"    float finalSecondaryOpacity = (\n"
"        (animateNoneSecondaryOpacity * float(orbAnimation == animateNone)) +\n"
"        (animateDissipateSecondaryOpacity * float(orbAnimation == animateDissipate)) +\n"
"        (animateExplodeSecondaryOpacity * float(orbAnimation == animateExplode)) +\n"
"        (animateFadeSecondaryOpacity * float(orbAnimation == animateFade)) +\n"
"        (animateFlickerSecondaryOpacity * float(orbAnimation == animateFlicker)) +\n"
"        (animateDimSecondaryOpacity * float(orbAnimation == animateDim))\n"
"    );\n"
"\n"
"//    return vec4(0.5);\n"
"    // We only use secondary color table for fireblast.\n"
"    return calcPrimaryColor(orbStyle, finalRadius, finalIntensity, finalPrimaryColor, secondaryColor, finalOpacity, scaledNoise);\n"
"}\n"
"\n"
"vec4 calcOrbColor (vec2 quadSize) {\n"
"    float orbRadius = ((quadSize[0] + quadSize[1]) / 2.0) / 2.0;\n"
"    float animatedNoise = fbmAnimated(((quadPos + 1.0) / orb_fbm_space_divisor), current_tick / orb_fbm_time_divisor) + 0.5;\n"
"    float scaledNoise = fbmAnimated((quadPos + 1.0) / (orbRadius / 50), current_tick / orb_fbm_time_divisor) + 0.5;\n"
"    vec4 finalColor = calcAnimationColor(animatedNoise, scaledNoise, orbRadius);\n"
"	finalColor[0] = max(finalColor[0], 0.0); // if finalColor[3] is nan, set it to zero\n"
"	finalColor[1] = max(finalColor[1], 0.0); // if finalColor[3] is nan, set it to zero\n"
"	finalColor[2] = max(finalColor[2], 0.0); // if finalColor[3] is nan, set it to zero\n"
"	finalColor[3] = max(finalColor[3], 0.0); // if finalColor[3] is nan, set it to zero\n"
"    return finalColor;\n"
"}\n"
"\n"
"// BEGIN PARTICLE SUBSHADER\n"
"\n"
"\n"
"const int particleTypeGaseous = 1;\n"
"const int particleTypeFire = 2;\n"
"const int particleTypeSmoke = 3;\n"
"const int particleTypeImage = 4; // This is not handled here; it is handled by the texture shader\n"
"const int particleTypeLine = 5; // This is not handled here; it is handled by the ray shader\n"
"const int particleTypeGlitter = 6;\n"
"\n"
"\n"
"float AngleRange (float fMinAngle, float fMaxAngle) {\n"
"    bool useCase1 = fMinAngle > fMaxAngle;\n"
"    float case1 = fMaxAngle + (2 * PI) - fMinAngle;\n"
"    float case2 = fMaxAngle - fMinAngle;\n"
"    return (float(useCase1) * case1) + (float(!useCase1) * case2);\n"
"}\n"
"\n"
"float AngleBearing (float fDir, float fTarget) {\n"
"    float fBearing = AngleRange(fDir, fTarget);\n"
"    bool over360 = (fBearing > PI);\n"
"    return (float(over360) * (fBearing - (2 * PI))) + (float(!over360) * fBearing);\n"
"}\n"
"\n"
"vec4 calcParticleColorGlitter(float fMaxRadius, float fMinRadius, vec3 vPrimaryColor, vec3 vSecondaryColor, float fOpacity, float particleRotation) {\n"
"    const float HIGHLIGHT_ANGLE = (2 * PI) / 135;\n"
"    const float HIGHLIGHT_RANGE = (2 * PI) / 30;\n"
"    float fBearing = abs(AngleBearing(HIGHLIGHT_ANGLE, mod(particleRotation, (2*PI))));\n"
"    bool bFaded = (fBearing < HIGHLIGHT_RANGE);\n"
"    vec3 rgbColor = mix(vSecondaryColor, vPrimaryColor, min(1.0, fBearing / HIGHLIGHT_RANGE));\n"
"    vec3 finalRgbColor = (rgbColor * float(bFaded)) + (vPrimaryColor * float(!bFaded));\n"
"\n"
"    float alpha = fOpacity * float(pixelsDistanceFromCenter < fMaxRadius);\n"
"    return vec4(finalRgbColor, alpha);\n"
"}\n"
"\n"
"\n"
"vec4 calcParticleColorFlame(float fMaxRadius, float fMinRadius, float fOpacity, float fCore, float fFlame, float fSmoke, float fSmokeBrightness, int iLifetime, int iCurrFrame, int particleDestiny) {\n"
"    vec3 FLAME_CORE_COLOR = vec3(1.0, 0.94, 0.90);\n"
"    vec3 FLAME_MIDDLE_COLOR = vec3(1.0, 0.82, 0.0);\n"
"    vec3 FLAME_OUTER_COLOR = vec3(1.0, 0.23, 0.11);\n"
"\n"
"    float fLifetime = float(max(1, iLifetime));\n"
"	float fCurrFrame = float(iCurrFrame);\n"
"    float fLifeLeft = fLifetime - fCurrFrame;\n"
"\n"
"    float fFade = max(20.0 / 255.0, min(1.0, (1.0 * fLifeLeft / fLifetime)));\n"
"    float fFade2 = 0.0;\n"
"    float fCurrRadius = fMinRadius + ((fMaxRadius - fMinRadius) * fCurrFrame / fLifetime);\n"
"    float alpha = mix(fFade, fFade2, pixelsDistanceFromCenter / fCurrRadius) * float(pixelsDistanceFromCenter <= fCurrRadius);\n"
"    float fSmokeColor = min(1.0, fSmokeBrightness + (2.0 * (1.0 / 255.0) * float(mod(particleDestiny, 25))));\n"
"    vec3 rgbSmokeColor = vec3(fSmokeColor);\n"
"    bool useFlameOuterColor = (mod(particleDestiny, 4) != 0);\n"
"    vec3 rgbOuterColor = (float(useFlameOuterColor) * FLAME_OUTER_COLOR) + (float(!useFlameOuterColor) * rgbSmokeColor);\n"
"\n"
"    bool useCoreColor = fCurrFrame <= fCore;\n"
"    vec3 coreColor = mix(FLAME_CORE_COLOR, FLAME_MIDDLE_COLOR, min(1.0, float(fCurrFrame) / fCore)) * float(useCoreColor);\n"
"    bool useFlameColor = (fCurrFrame <= fFlame) && !useCoreColor;\n"
"    vec3 flameColor = mix(FLAME_MIDDLE_COLOR, rgbOuterColor, max(0.0, min(1.0, float(fCurrFrame - fCore) / (fFlame - fCore)))) * float(useFlameColor);\n"
"    bool useSmokeColor = (fCurrFrame <= fSmoke) && (!useCoreColor) && (!useFlameColor);\n"
"    vec3 smokeColor = mix(rgbOuterColor, rgbSmokeColor, max(0.0, min(1.0, float(fCurrFrame - fFlame) / (fSmoke - fFlame)))) * float(useSmokeColor);\n"
"    bool useFadeColor = fCurrFrame > fSmoke;\n"
"    vec3 fadeColor = rgbSmokeColor * float(useFadeColor);\n"
"\n"
"    vec3 color = coreColor + flameColor + smokeColor + fadeColor;\n"
"    return vec4(color, alpha);\n"
"}\n"
"\n"
"vec4 calcParticleColorSmoke(float fMaxRadius, float fMinRadius, float fOpacity, int iLifetime, int iCurrFrame, int particleDestiny) {\n"
"float fLifetime = float(iLifetime);\n"
"return calcParticleColorFlame(fMaxRadius, fMinRadius, fOpacity, 1.0, max(1.0, fLifetime / 6.0), max(1.0, fLifetime / 4.0), 60.0, iLifetime, iCurrFrame, particleDestiny);\n"
"}\n"
"\n"
"vec4 calcParticleColorFire(float fMaxRadius, float fMinRadius, float fOpacity, int iLifetime, int iCurrFrame, int particleDestiny) {\n"
"float fLifetime = float(iLifetime);\n"
"return calcParticleColorFlame(fMaxRadius, fMinRadius, fOpacity, max(1.0, fLifetime / 6.0), max(1.0, fLifetime / 2.0), max(1.0, 3.0 * (fLifetime / 4.0)), 80.0, iLifetime, iCurrFrame, particleDestiny);\n"
"}\n"
"\n"
"vec4 calcParticleColorGaseous(float fMaxRadius, float fMinRadius, vec3 vPrimaryColor, vec3 vSecondaryColor, float fOpacity, int iLifetime, int iCurrFrame) {\n"
"    float fLifetime = float(max(1, iLifetime));\n"
"    float fCurrFrame = float(iCurrFrame);\n"
"    float fLifeLeft = fLifetime - fCurrFrame;\n"
"\n"
"\n"
"    float fFade = max(20.0 / 255.0, min(1.0, (1.0 * fLifeLeft / fLifetime)));\n"
"    float fFade2 = fFade / 2.0;\n"
"    //float fFade2 = 0.0;\n"
"    float fCurrRadius = fMinRadius + ((fMaxRadius - fMinRadius) * fCurrFrame / fLifetime);\n"
"    //float fCurrRadius = 500.0;\n"
"    float alpha = mix(fFade, fFade2, min(4.0, pixelsDistanceFromCenter) / fCurrRadius) * float(pixelsDistanceFromCenter <= fCurrRadius);\n"
"    //float alpha = max(0.0, fOpacity - ((pixelsDistanceFromCenter * fOpacity) / fRadius));\n"
"    vec3 color = mix(vPrimaryColor, vSecondaryColor, fCurrFrame / fLifetime) * float(pixelsDistanceFromCenter <= fCurrRadius);\n"
"    return vec4(color, fFade) * float(pixelsDistanceFromCenter <= fCurrRadius);\n"
"}\n"
"\n"
"vec4 calcParticleColor(vec2 quadSize, float fMinRadius, vec3 primaryColor, vec3 secondaryColor, float opacityAdj, int lifeTime, int currFrame, float particleRotation, int style, int particleDestiny) {\n"
"    float fMaxRadius = ((quadSize[0] + quadSize[1]) / 2.0) / 2.0;\n"
"	vec4 finalColor = (\n"
"			(calcParticleColorGaseous(fMaxRadius, fMinRadius, primaryColor, secondaryColor, opacityAdj, lifeTime, currFrame) * float(style == particleTypeGaseous)) +\n"
"			(calcParticleColorGlitter(fMaxRadius, fMinRadius, primaryColor, secondaryColor, opacityAdj, particleRotation) * float(style == particleTypeGlitter)) +\n"
"			(calcParticleColorFire(fMaxRadius, fMinRadius, opacityAdj, lifeTime, currFrame, particleDestiny) * float(style == particleTypeFire)) +\n"
"			(calcParticleColorSmoke(fMaxRadius, fMinRadius, opacityAdj, lifeTime, currFrame, particleDestiny) * float(style == particleTypeSmoke))\n"
"		);\n"
"	return finalColor;\n"
"}\n"
"\n"
"void main(void)\n"
"{\n"
"    float center_point = 0.0; // Remember to remove this in the real shader!!\n"
"    vec2 real_texcoord = quadPos;\n"
"\n"
"	vec4 finalColor = (\n"
"		(calcRayLightningColor(quadSize, real_texcoord, rayWaveCyclePos, rayGrainyTexture, rayReshape, rayWidthAdjType, center_point, opacityAdj, orbSecondaryOpacity) * float((effectType == effectTypeRay) || (effectType == effectTypeLightning))) +\n"
"		(calcOrbColor(quadSize) * float(effectType == effectTypeOrb)) +\n"
"		(calcParticleColor(quadSize, particleMinRadius, primaryColor, secondaryColor, opacityAdj, orbLifetime, orbCurrFrame, rotation, orbStyle, particleDestiny) * float(effectType == effectTypeParticle))\n"
"	);\n"
"\n"
"	bool usePreMultipliedAlpha = (\n"
"		(blendMode == blendScreen)\n"
"	);\n"
"\n"
"	vec3 finalColorRGB = (vec3(finalColor[0], finalColor[1], finalColor[2]) * float(!usePreMultipliedAlpha)) + (vec3(finalColor[0], finalColor[1], finalColor[2]) * float(usePreMultipliedAlpha) * finalColor[3]);\n"
"\n"
"	float epsilon = 0.01;\n"
"	bool alphaIsZero = finalColor[3] < epsilon;\n"
"	gl_FragDepth = depth + float(alphaIsZero && (finalColor[3] < epsilon));\n"
"    fragColor = vec4(finalColorRGB[0], finalColorRGB[1], finalColorRGB[2], finalColor[3]);\n"
"}\n";
const std::string FOrbShader =
"#version 410 core\n"
"\n"
"\n"
"\n"
"// The shader used in RayRasterizer comprises the following:\n"
"// -Width specification. The RayRasterizer draws a line in an arbitrary direction, then extends it width-wise.\n"
"// What we can do is to transform a pixel back to a given rotational frame using the rotation, then using the distance\n"
"// from the axis to get the width. Note, the C code uses a WidthCount and LengthCount to divide the ray into cells.\n"
"// We can use modulos and similar methods to determine which cell our pixel is in.\n"
"// -Length specification. There is an array of lengths in the C code; we can just pass the specified one directly into\n"
"// our VBO. It is specified as a number of length "cells" in the C code, but this is what is meant (?)\n"
"// Following variables will be required:\n"
"// Direct from GeorgeCode: iColorTypes, iOpacityTypes, iWidthAdjType, iReshape, iTexture\n"
"\n"
"\n"
"// GeorgeCode defines incrementor as such:\n"
"//            Metric rStep = (Metric)iStep / (Metric)m_iSteps;\n"
"//            return m_rStart + (pow(rStep, m_rPower) * m_rRange);\n"
"// m_iSteps, m_rPower, m_rStart and m_rRange specified in incrementor. iStep is the input argument to GetAt(int iStep).\n"
"\n"
"layout (location = 0) in vec2 quadPos;\n"
"layout (location = 1) flat in int animation; //\n"
"layout (location = 2) flat in int style; //\n"
"layout (location = 3) flat in int opacity;\n"
"layout (location = 4) flat in int distortion;\n"
"layout (location = 5) in float depth; //\n"
"layout (location = 6) in float intensity; //\n"
"layout (location = 7) in vec3 primaryColor; //\n"
"layout (location = 8) in vec3 secondaryColor; //\n"
"layout (location = 9) in float waveCyclePos; // not used here\n"
"layout (location = 10) flat in int colorTypes; // not used here\n"
"layout (location = 11) in float opacityAdj;\n"
"layout (location = 12) in vec2 quadSize;\n"
"layout (location = 13) flat in int detail;\n"
"layout (location = 14) in float orbRadius;\n"
"layout (location = 15) in float secondaryOpacity;\n"
"layout (location = 16) flat in int lifetime;\n"
"layout (location = 17) flat in int currFrame;\n"
"layout (location = 18) flat in int animationSeed;\n"
"\n"
"uniform float current_tick;\n"
"\n"
"out vec4 fragColor;\n"
"\n"
"float pixelsDistanceFromCenter = length(quadPos) * (quadSize[0] / 2);\n"
"\n"
"float PI = 3.14159;\n"
"float SHELL_EDGE_WIDTH_RATIO = 0.05;\n"
"\n"
"float BLOB_WAVE_SIZE = 0.3;\n"
"float WAVY_WAVELENGTH_FACTOR = 1.0;\n"
"float JAGGED_AMPLITUDE = 0.45;\n"
"float JAGGED_WAVELENGTH_FACTOR = 0.33;\n"
"float WHIPTAIL_AMPLITUDE = 0.45;\n"
"float WHIPTAIL_WAVELENGTH_FACTOR = 1.0;\n"
"float WHIPTAIL_DECAY = 0.13;\n"
"\n"
"// Copy of EAnimationTypes enum from SFXOrb.cpp\n"
"int animateNone =           0;\n"
"int animateDissipate =      1;\n"
"int animateExplode =        2;\n"
"int animateFade =           3;\n"
"int animateFlicker =        4;\n"
"int animateDim =            5;\n"
"\n"
"// Copy of EOrbStyles enum from SFXOrb.cpp\n"
"int styleSmooth =           1;\n"
"int styleFlare =            2;\n"
"int styleCloud =            3;\n"
"int styleFireblast =        4;\n"
"int styleSmoke =            5;\n"
"int styleDiffraction =      6;\n"
"int styleFirecloud =        7;\n"
"int styleBlackHole =        8;\n"
"int styleLightning =        9;\n"
"int styleShell =            10;\n"
"int styleCloudshell =       11;\n"
"int styleFireCloudshell =   12;\n"
"\n"
"//  Classic Perlin 3D Noise \n"
"//  by Stefan Gustavson\n"
"//\n"
"//  Found at https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n"
"vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\n"
"vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n"
"vec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n"
"\n"
"float cnoise(vec3 P){\n"
"  vec3 Pi0 = floor(P); // Integer part for indexing\n"
"  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n"
"  Pi0 = mod(Pi0, 289.0);\n"
"  Pi1 = mod(Pi1, 289.0);\n"
"  vec3 Pf0 = fract(P); // Fractional part for interpolation\n"
"  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n"
"  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n"
"  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n"
"  vec4 iz0 = Pi0.zzzz;\n"
"  vec4 iz1 = Pi1.zzzz;\n"
"\n"
"  vec4 ixy = permute(permute(ix) + iy);\n"
"  vec4 ixy0 = permute(ixy + iz0);\n"
"  vec4 ixy1 = permute(ixy + iz1);\n"
"\n"
"  vec4 gx0 = ixy0 / 7.0;\n"
"  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n"
"  gx0 = fract(gx0);\n"
"  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n"
"  vec4 sz0 = step(gz0, vec4(0.0));\n"
"  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n"
"  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n"
"\n"
"  vec4 gx1 = ixy1 / 7.0;\n"
"  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n"
"  gx1 = fract(gx1);\n"
"  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n"
"  vec4 sz1 = step(gz1, vec4(0.0));\n"
"  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n"
"  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n"
"\n"
"  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n"
"  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n"
"  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n"
"  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n"
"  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n"
"  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n"
"  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n"
"  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n"
"\n"
"  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n"
"  g000 *= norm0.x;\n"
"  g010 *= norm0.y;\n"
"  g100 *= norm0.z;\n"
"  g110 *= norm0.w;\n"
"  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n"
"  g001 *= norm1.x;\n"
"  g011 *= norm1.y;\n"
"  g101 *= norm1.z;\n"
"  g111 *= norm1.w;\n"
"\n"
"  float n000 = dot(g000, Pf0);\n"
"  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n"
"  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n"
"  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n"
"  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n"
"  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n"
"  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n"
"  float n111 = dot(g111, Pf1);\n"
"\n"
"  vec3 fade_xyz = fade(Pf0);\n"
"  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n"
"  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n"
"  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n"
"  return 2.2 * n_xyz;\n"
"}\n"
"\n"
"\n"
"float fbm(vec2 p, float time)\n"
"{\n"
"    // Fractal Brownian Motion using Perlin noise\n"
"     float v = 0.0;\n"
"     float amp = 0.3;\n"
"     float freq = 20;\n"
"     int octaves = 3;\n"
"     for (int i = 0; i < octaves; i++)\n"
"         v += cnoise(vec3(((p + vec2(1000.0, 1000.0)) * (i * freq)), time / 100)) * (amp / (i + 1));\n"
"\n"
"     return v;\n"
"}\n"
"\n"
"vec3 getExplosionColor(float fRadius, float fMaxRadius, float fIntensity, vec3 vPrimaryColor, vec3 vSecondaryColor) {\n"
"    const float SIGMA_MAX =                    0.01;\n"
"    const float SIGMA_DECAY =                  1.07;\n"
"    const float MAX_INTENSITY =                100.0;\n"
"    \n"
"    \n"
"    const float CORE_HEAT_LEVEL =              0.5;\n"
"    const float FRINGE_HEAT_LEVEL =            0.35;\n"
"    const float FRINGE_HEAT_RANGE =            (CORE_HEAT_LEVEL - FRINGE_HEAT_LEVEL);\n"
"    const float FLAME_HEAT_LEVEL =             0.25;\n"
"    const float FLAME_HEAT_RANGE =             (FRINGE_HEAT_LEVEL - FLAME_HEAT_LEVEL);\n"
"    const float MIN_HEAT_LEVEL =               0.1;\n"
"    const float MIN_HEAT_RANGE =               (FLAME_HEAT_LEVEL - MIN_HEAT_LEVEL);\n"
"    \n"
"    float fHeatCalcIntensity = min(fIntensity, 100);\n"
"    float fHeatCountRadius = fRadius / fMaxRadius;\n"
"    \n"
"    float fSigma2 = SIGMA_MAX * pow(SIGMA_DECAY, MAX_INTENSITY - fHeatCalcIntensity);\n"
"    float fSigma = sqrt(fSigma2);\n"
"    float fMaxX = sqrt(2) * sqrt(fSigma2 * log(1.0 / (fSigma * MIN_HEAT_LEVEL * sqrt(2 * 3.14159))));\n"
"    float fX = fMaxX * (fHeatCountRadius);\n"
"    float fHeat = (1.0 / (fSigma * sqrt(2 * 3.14159))) * exp((-fX * fX) / (2.0 * fSigma2));\n"
"    \n"
"    bool useCoreColor = (fHeat > CORE_HEAT_LEVEL);\n"
"    vec3 coreColor = float(useCoreColor) * vec3(1.0);\n"
"    \n"
"    bool useFringeColor = (fHeat > FRINGE_HEAT_LEVEL) && !useCoreColor;\n"
"    vec3 fringeColor = float(useFringeColor) * mix(vPrimaryColor, vec3(1.0), (fHeat - FRINGE_HEAT_LEVEL) / FRINGE_HEAT_RANGE);\n"
"    \n"
"    bool useFlameColor = (fHeat > FLAME_HEAT_LEVEL) && !useFringeColor && !useCoreColor;\n"
"    vec3 flameColor = float(useFlameColor) * mix(vSecondaryColor, vPrimaryColor, pow((fHeat - FLAME_HEAT_LEVEL) * float(useFlameColor) / FLAME_HEAT_RANGE, 0.5));\n"
"    \n"
"    bool useSecondaryColor = (!useCoreColor) && (!useFringeColor) && (!useFlameColor);\n"
"    vec3 secondaryColor = float(useSecondaryColor) * vSecondaryColor;\n"
"    //return vec3(fHeat);\n"
"    return coreColor + fringeColor + flameColor + secondaryColor;\n"
"}\n"
"\n"
"// ORB FUNCTIONS BEGIN HERE!\n"
"\n"
"vec4 calcSmoothColorBase(float fRadius, float fIntensity, vec3 vPrimaryColor, vec3 vSecondaryColor, float fOpacity, vec3 blownColor) {\n"
"    float fFringeMaxRadius = fRadius * (fIntensity / 120.0);\n"
"    float fFringeWidth = fFringeMaxRadius / 8.0;\n"
"    float fBlownRadius = fFringeMaxRadius - fFringeWidth;\n"
"    float fFadeWidth = fRadius - fFringeMaxRadius;\n"
"    \n"
"    // White within blown radius, 100% opacity\n"
"    bool useBlownRadius = (pixelsDistanceFromCenter < fBlownRadius);\n"
"    vec4 blownRadiusColor = float(useBlownRadius) * vec4(blownColor, fOpacity);\n"
"    \n"
"    // Mix between primary color and white in fringe radius\n"
"    bool useFringeRadius = (pixelsDistanceFromCenter < fFringeMaxRadius && fFringeWidth > 0.0 && pixelsDistanceFromCenter >= fBlownRadius);\n"
"    float fringeOpacityStep = (pixelsDistanceFromCenter - fBlownRadius);\n"
"    float fringeOpacity = (fringeOpacityStep * fOpacity) / fFringeWidth;\n"
"    vec3 fringeRadiusColorRGB = mix(vec3(1.0, 1.0, 1.0), vec3(vPrimaryColor), fringeOpacity);\n"
"    vec4 fringeRadiusColor = float(useFringeRadius) * vec4(fringeRadiusColorRGB, fOpacity);\n"
"    \n"
"    \n"
"    // Secondary color in fade radius\n"
"    bool useFadeRadius = (pixelsDistanceFromCenter < fRadius && (pixelsDistanceFromCenter >= fFringeMaxRadius || fFringeWidth <= 0.0) && fFadeWidth > 0.0);\n"
"    float fadeOpacityStep = (pixelsDistanceFromCenter - fFringeMaxRadius);\n"
"    float fadeOpacity = 1.0 - (fadeOpacityStep / fFadeWidth);\n"
"    fadeOpacity = (fadeOpacity * fadeOpacity) * fOpacity;\n"
"    vec4 fadeRadiusColor = float(useFadeRadius) * vec4(vSecondaryColor, fadeOpacity);\n"
"    \n"
"    // Black otherwise\n"
"    bool useBlackRadius = (pixelsDistanceFromCenter > fRadius);\n"
"    vec4 blackRadiusColor = float(useBlackRadius) * vec4(0.0);\n"
"    \n"
"    return (blownRadiusColor + fringeRadiusColor + fadeRadiusColor + blackRadiusColor);\n"
"}\n"
"\n"
"float rand(vec2 co){\n"
"  // Canonical PRNG from https://stackoverflow.com/questions/12964279/whats-the-origin-of-this-glsl-rand-one-liner\n"
"  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n"
"}\n"
"\n"
"float FloatIncrementor(float start, float power, float limit, float end, float inputValue) {\n"
"    float range = end - start;\n"
"    float currStep = inputValue / limit;\n"
"    return (start + pow(currStep, power) * range);\n"
"}\n"
"\n"
"float CalcShellOpacity(float fRadius, float fIntensity, float fOpacity) {\n"
"/*\n"
"    ASSERT(iRadius >= 0);\n"
"    ASSERT(iShellMaxRadius >= 0);\n"
"\n"
"    iIntensity = Max(0, Min(iIntensity, 100));\n"
"    iShellMaxRadius = Min(iShellMaxRadius, iRadius);\n"
"    int iEdgeWidth = iRadius - iShellMaxRadius;\n"
"\n"
"    if (retOpacity.GetCount() < iRadius)\n"
"        retOpacity.InsertEmpty(iRadius - retOpacity.GetCount());\n"
"\n"
"    CStepIncrementor MaxIntensity(CStepIncrementor::styleOct, 0.0, 1.0, iShellMaxRadius);\n"
"    CStepIncrementor MinIntensity(CStepIncrementor::styleLinear, 0.0, 1.0, iShellMaxRadius);\n"
"    Metric rMaxIntensityK = iIntensity / 100.0;\n"
"    Metric rMinIntensityK = (100 - iIntensity) / 100.0;\n"
"\n"
"    for (int i = 0; i < iShellMaxRadius; i++)\n"
"        retOpacity[i] = (BYTE)(byOpacity * ((MaxIntensity.GetAt(i) * rMaxIntensityK) + (MinIntensity.GetAt(i) * rMinIntensityK)));\n"
"\n"
"    CStepIncrementor Fade(CStepIncrementor::styleSquare, 1.0, 0.0, iEdgeWidth + 1);\n"
"    for (int i = 0; i < iEdgeWidth; i++)\n"
"        retOpacity[iShellMaxRadius + i] = (BYTE)(byOpacity * Fade.GetAt(1 + i));\n"
"    */\n"
"    float fEdgeWidthForMaxRadius = fRadius * SHELL_EDGE_WIDTH_RATIO;\n"
"    float fShellMaxRadius = fRadius - fEdgeWidthForMaxRadius;\n"
"    \n"
"    float fCappedIntensity = max(0.0, min(fIntensity, 100.0));\n"
"    fShellMaxRadius = min(fShellMaxRadius, fRadius);\n"
"    float fEdgeWidth = fRadius - fShellMaxRadius;\n"
"\n"
"    float fMaxIntensity = FloatIncrementor(0.0, 8.0, fShellMaxRadius, 1.0, pixelsDistanceFromCenter);\n"
"    float fMinIntensity = FloatIncrementor(0.0, 1.0, fShellMaxRadius, 1.0, pixelsDistanceFromCenter);\n"
"    float fMaxIntensityK = fIntensity / 100.0;\n"
"    float fMinIntensityK = (100 - fIntensity) / 100.0;\n"
"    float fFade = FloatIncrementor(1.0, 2.0, fEdgeWidth + 1.0, 1.0, (1.0 + pixelsDistanceFromCenter));\n"
"\n"
"    bool useInnerOpacity = pixelsDistanceFromCenter < fShellMaxRadius;\n"
"    float innerOpacity = fOpacity * ((fMaxIntensity * fMaxIntensityK) + (fMinIntensity * fMinIntensityK)) * float(useInnerOpacity);\n"
"    bool useOuterOpacity = (pixelsDistanceFromCenter >= fShellMaxRadius) && (pixelsDistanceFromCenter < fEdgeWidth);\n"
"    float outerOpacity = fOpacity * fFade * float(useOuterOpacity);\n"
"    return innerOpacity + outerOpacity;\n"
"}\n"
"\n"
"vec4 calcShellColor(float fRadius, float fIntensity, vec3 vPrimaryColor, vec3 vSecondaryColor, float fShellOpacity) {\n"
"/*\n"
"    ASSERT(iRadius >= 0);\n"
"\n"
"    if (retColorTable->GetCount() < iRadius)\n"
"        retColorTable->InsertEmpty(iRadius - retColorTable->GetCount());\n"
"\n"
"    int iEdgeWidth = mathRound(iRadius * SHELL_EDGE_WIDTH_RATIO);\n"
"    int iShellMaxRadius = iRadius - iEdgeWidth;\n"
"    int iHoleRadius = iShellMaxRadius * iIntensity / 120;\n"
"\n"
"    TArray<BYTE> OpacityRamp;\n"
"    CalcShellOpacity(iRadius, iShellMaxRadius, iIntensity, byOpacity, OpacityRamp);\n"
"\n"
"    //  Initialize table\n"
"\n"
"    for (int i = 0; i < iRadius; i++)\n"
"        {\n"
"        if (i < iHoleRadius)\n"
"            (*retColorTable)[i] = CG32bitPixel(rgbSecondary, OpacityRamp[i]);\n"
"\n"
"        else if (i < iShellMaxRadius)\n"
"            {\n"
"            int iStep = (i - iHoleRadius);\n"
"            DWORD dwBlend = 255 * iStep / (iShellMaxRadius - iHoleRadius);\n"
"            (*retColorTable)[i] = CG32bitPixel(CG32bitPixel::Blend(rgbSecondary, rgbPrimary, (BYTE)dwBlend), OpacityRamp[i]);\n"
"            }\n"
"        else\n"
"            (*retColorTable)[i] = CG32bitPixel(rgbPrimary, OpacityRamp[i]);\n"
"        }\n"
"    }\n"
"    */\n"
"    float fEdgeWidth = fRadius * SHELL_EDGE_WIDTH_RATIO;\n"
"    float fShellMaxRadius = fRadius - fEdgeWidth;\n"
"    float fHoleRadius = fShellMaxRadius * fIntensity / 120;\n"
"    \n"
"    bool useHoleColor = (pixelsDistanceFromCenter < fHoleRadius);\n"
"    vec4 holeColor = float(useHoleColor) * vec4(vSecondaryColor, fShellOpacity);\n"
"    \n"
"    bool useShellColor = (!useHoleColor) && (pixelsDistanceFromCenter < fShellMaxRadius);\n"
"    float blend = (pixelsDistanceFromCenter - fHoleRadius) / (fShellMaxRadius - fHoleRadius);\n"
"    vec4 shellColor = float(useShellColor) * vec4(mix(vSecondaryColor, vPrimaryColor, blend), fShellOpacity);\n"
"    \n"
"    bool useOuterColor = (!useHoleColor) && (!useShellColor);\n"
"    vec4 outerColor = float(useOuterColor) * vec4(vPrimaryColor, fShellOpacity);\n"
"    \n"
"    return holeColor + shellColor + outerColor;\n"
"}\n"
"\n"
"vec4 calcSmoothColor(float fRadius, float fIntensity, vec3 vPrimaryColor, vec3 vSecondaryColor, float fOpacity) {\n"
"    return calcSmoothColorBase(fRadius, fIntensity, vPrimaryColor, vSecondaryColor, fOpacity, vec3(1.0, 1.0, 1.0));\n"
"}\n"
"\n"
"vec4 calcBlackHoleColor(float fRadius, float fIntensity, vec3 vPrimaryColor, vec3 vSecondaryColor, float fOpacity) {\n"
"    return calcSmoothColorBase(fRadius, fIntensity, vPrimaryColor, vSecondaryColor, fOpacity, vec3(0.0, 0.0, 0.0));\n"
"}\n"
"\n"
"vec4 calcFlareColor(float fRadius, float fIntensity, vec3 vPrimaryColor, vec3 vSecondaryColor, float fOpacity) {\n"
"    vec3 centerColor = mix(vPrimaryColor, vec3(1.0, 1.0, 1.0), fIntensity / 100.0);\n"
"    vec3 edgeColor = vSecondaryColor;\n"
"    float fFade = pixelsDistanceFromCenter / fRadius;\n"
"    vec3 rgbColor = mix(centerColor, edgeColor, fFade);\n"
"    float alpha = max(0.0, fOpacity - ((pixelsDistanceFromCenter * fOpacity) / fRadius));\n"
"    return vec4(rgbColor, alpha);\n"
"}\n"
"\n"
"vec4 calcDiffractionColor(float fRadius, float fIntensity, vec3 vPrimaryColor, vec3 vSecondaryColor, float fOpacity, vec4 flareColor) {\n"
"    float ring_pixel_distance = 2.0;\n"
"    float modVal = mod(pixelsDistanceFromCenter, ring_pixel_distance);\n"
"    float useEvenColor = abs(modVal - (ring_pixel_distance / 2.0)) / (ring_pixel_distance / 2.0);\n"
"    vec3 evenColor = mix(vec3(0.0, 0.0, 0.0), vec3(flareColor), 0.5);\n"
"    vec3 oddColor = mix(vec3(flareColor), vec3(1.0, 1.0, 1.0), 0.5);\n"
"    vec4 fColor = vec4(mix(oddColor, evenColor, useEvenColor), flareColor[3]);\n"
"    return fColor;\n"
"}\n"
"\n"
"vec4 calcCloudRadialColor(float fRadius, float fIntensity, vec3 vPrimaryColor, vec3 vSecondaryColor, float fOpacity) {\n"
"    float cloudOpacity = FloatIncrementor(fOpacity, 2.0, fRadius, 0.0, pixelsDistanceFromCenter);\n"
"    return vec4(1.0, 1.0, 1.0, cloudOpacity);\n"
"}\n"
"\n"
"vec4 calcCloudShellRadialColor(float fRadius, float fIntensity, vec3 vPrimaryColor, vec3 vSecondaryColor, float fOpacity) {\n"
"    return vec4(1.0, 1.0, 1.0, fOpacity);\n"
"}\n"
"\n"
"vec4 calcSmokeRadialColor(float fRadius, float fIntensity, vec3 vPrimaryColor, vec3 vSecondaryColor, float fOpacity) {\n"
"    float fOpacityValue = FloatIncrementor(fOpacity, 4.0, fRadius, 0.0, pixelsDistanceFromCenter);\n"
"    float fCenterAdj = FloatIncrementor(max(0.0, (70.0 - fIntensity)) / 100.0, 2.0, fRadius, 1.0, pixelsDistanceFromCenter);\n"
"    return vec4(mix(vPrimaryColor, vSecondaryColor, pixelsDistanceFromCenter / fRadius), fCenterAdj * fOpacityValue);\n"
"}\n"
"\n"
"vec4 calcCloudPixelColor(float fRadius, float fIntensity, float fLookupValue, vec3 vPrimaryColor, vec3 vSecondaryColor, float fOpacity) {\n"
"    float fHighAdj = fOpacity;\n"
"    float fLowAdj = 1.0 - fHighAdj;\n"
"    \n"
"    float newOpacity = fHighAdj + (fLookupValue * fLowAdj);\n"
"    return vec4(mix(vSecondaryColor, vPrimaryColor, fLookupValue), newOpacity);\n"
"}\n"
"\n"
"vec4 calcCloudColor(vec4 radialColor, vec4 pixelColor) {\n"
"    return vec4(pixelColor[0], pixelColor[1], pixelColor[2], pixelColor[3] * radialColor[3]);\n"
"}\n"
"\n"
"vec4 calcFirecloudPixelColor(float fRadius, float fIntensity, float fLookupValue, vec3 vPrimaryColor, vec3 vSecondaryColor, float fOpacity) {\n"
"    float fHighAdj = fOpacity;\n"
"    float fLowAdj = 1.0 - fHighAdj;\n"
"    \n"
"    float newOpacity = fHighAdj + (fLookupValue * fLowAdj);\n"
"    return vec4(getExplosionColor(fLookupValue, 1.0, fIntensity, vPrimaryColor, vSecondaryColor), newOpacity);\n"
"}\n"
"\n"
"vec4 calcFireblastRadialColor(float fRadius, float fIntensity, float queryRadius, vec3 vPrimaryColor, vec3 vSecondaryColor, float fOpacity) {\n"
"    float BLOWN_INTENSITY = 95.0;\n"
"    float BLOWN_SIZE = 100.0 - BLOWN_INTENSITY;\n"
"    float FIRE_INTENSITY = 80.0;\n"
"    float FIRE_SIZE = BLOWN_INTENSITY - FIRE_INTENSITY;\n"
"    float GLOW_INTENSITY = 25.0;\n"
"    float GLOW_SIZE = FIRE_INTENSITY - GLOW_INTENSITY;\n"
"    float FADE_INTENSITY = 0.0;\n"
"    float FADE_SIZE = GLOW_INTENSITY - FADE_INTENSITY;\n"
"    //CStepIncrementor Opacity(CStepIncrementor::styleSquare, byOpacity, 0.0, iRadius);\n"
"    FloatIncrementor(fOpacity, 2.0, fRadius, 0.0, pixelsDistanceFromCenter);\n"
"    \n"
"    float fOpacityInc = FloatIncrementor(fOpacity, 8.0, fRadius, 0.0, queryRadius);\n"
"    float fRadiusInc = FloatIncrementor(0.0, 4.0, fRadius, 1.0, queryRadius);\n"
"    \n"
"    bool useBlown = (fIntensity > BLOWN_INTENSITY);\n"
"    float fBlownFade = min(FloatIncrementor(100.0, 8.0, BLOWN_SIZE, 0.0, fIntensity - BLOWN_INTENSITY), 100.0);\n"
"    vec3 fColCenterBlown = mix(vec3(1.0), vPrimaryColor, fBlownFade / 100.0) * float(useBlown);\n"
"    vec3 fColEdgeBlown = mix(vec3(1.0), vPrimaryColor, fBlownFade / 100.0) * float(useBlown);\n"
"    \n"
"    bool useFire = (fIntensity > FIRE_INTENSITY) && !useBlown;\n"
"    float fFireFade = min(FloatIncrementor(100.0, 8.0, FIRE_SIZE, 0.0, fIntensity - FIRE_INTENSITY), 100.0);\n"
"    vec3 fColCenterFire = vPrimaryColor * float(useFire);\n"
"    vec3 fColEdgeFire = mix(vPrimaryColor, vSecondaryColor, fFireFade / 100.0) * float(useFire);\n"
"    \n"
"    bool useGlow = (fIntensity > GLOW_INTENSITY) && !useFire && !useBlown;\n"
"    float fGlowFade = min(FloatIncrementor(100.0, 8.0, GLOW_SIZE, 0.0, fIntensity - GLOW_INTENSITY), 100.0);\n"
"    vec3 fColCenterGlow = mix(vPrimaryColor, vSecondaryColor, fGlowFade / 100.0) * float(useGlow);\n"
"    vec3 fColEdgeGlow = vSecondaryColor * float(useGlow);\n"
"    \n"
"    bool useFade = (fIntensity > FADE_INTENSITY) && !useGlow && !useFire && !useBlown;\n"
"    float fFadeFade = min(FloatIncrementor(100.0, 8.0, FADE_SIZE, 0.0, fIntensity - FADE_INTENSITY), 100.0);\n"
"    vec3 fColCenterFade = vSecondaryColor * float(useFade);\n"
"    vec3 fColEdgeFade = mix(vSecondaryColor, vec3(0.0), fFadeFade / 100.0) * float(useFade);\n"
"    \n"
"    vec3 fColCenter = fColCenterBlown + fColCenterFire + fColCenterGlow + fColCenterFade;\n"
"    vec3 fColEdge = fColEdgeBlown + fColEdgeFire + fColEdgeGlow + fColEdgeFade;\n"
"    \n"
"    //return vec4(vec3(fColCenterGlow), 1.0);\n"
"    return vec4(mix(fColCenter, fColEdge, fRadiusInc), fOpacityInc);\n"
"}\n"
"\n"
"vec4 calcFireblastPixelColor(float fRadius, float fIntensity, float queryRadius, vec3 vPrimaryColor, vec3 vSecondaryColor, float fOpacity) {\n"
"    float fIntensityInc = min(FloatIncrementor(100.0, 2.0, 100.0, 0.0, fIntensity), 100.0);\n"
"    float fOpacityInc = FloatIncrementor(fOpacity, 1.0, fRadius, 0.0, queryRadius);\n"
"    float fRadiusInc = FloatIncrementor(0.0, 1.0 / 8.0, fRadius, 1.0, queryRadius);\n"
"    \n"
"    vec3 fColCenter = mix(vPrimaryColor, vSecondaryColor, fIntensityInc / 100.0);\n"
"    vec3 fColEdge = mix(vSecondaryColor, vec3(0.0), fIntensityInc / 100.0);\n"
"    \n"
"    return vec4(mix(fColCenter, fColEdge, fRadiusInc), fOpacityInc);\n"
"}\n"
"\n"
"vec4 calcFireblastColor(float fRadius, float fIntensity, vec3 vPrimaryColor, vec3 vSecondaryColor, float fOpacity) {\n"
"    // Adjust radius between 1.0 times radius and (1.0 + disrupt) times radius\n"
"    float ANGLE_DISTORTION_MULTIPLIER = 0.4;\n"
"    // TODO: Add a seed!\n"
"    float angle_phase_adj = animationSeed * 3;\n"
"    float rand_noise_seed = animationSeed * 1;\n"
"    //float fAngle = (dot(quadPos, vec2(0.0, 1.0)) / length(quadPos));\n"
"    float fAngle = abs(mod(atan(quadPos.y, quadPos.x) + angle_phase_adj, (3.14159 * 2)) - 3.14159);//(dot(quadPos, vec2(0.0, 1.0)) / length(quadPos));\n"
"    float fRand = ((cnoise(vec3(fAngle * ANGLE_DISTORTION_MULTIPLIER + rand_noise_seed)) / 2.0) + 0.5);\n"
"    float fRadAdjFactor = (1 + (fRand * float(distortion) / 100.0));\n"
"    vec2 fAdjPos = quadPos * fRadAdjFactor;\n"
"    float fAdjRadius = pixelsDistanceFromCenter * fRadAdjFactor;\n"
"    //float fAdjRadius = pixelsDistanceFromCenter;\n"
"    bool useBlack = (fAdjRadius >= fRadius);\n"
"    \n"
"    float fNoiseValue = fbm(fAdjPos, current_tick) + 0.5;\n"
"\n"
"    vec4 fireblastPixelColor = calcFireblastPixelColor(fRadius, fIntensity, fAdjRadius, vPrimaryColor, vSecondaryColor, fOpacity);    \n"
"    vec4 fireblastRadialColor = calcFireblastRadialColor(fRadius, fIntensity, fAdjRadius, vPrimaryColor, vSecondaryColor, fOpacity);    \n"
"    \n"
"    //return vec4(fAdjRadius) / 300;\n"
"    return mix(fireblastRadialColor, fireblastPixelColor, fNoiseValue) * float(!useBlack);\n"
"}\n"
"\n"
"vec4 calcPrimaryColor(int iStyle, float fRadius, float fIntensity, vec3 vPrimaryColor, vec3 vSecondaryColor, float fOpacity, float noise) {\n"
"    // Switch for styles.\n"
"    // This is analogous to CalcSphericalColorTable in georgecode.\n"
"    float shellOpacity = CalcShellOpacity(fRadius, fIntensity, fOpacity); // used for shell, cloudshell\n"
"    vec4 cloudRadialColor = calcCloudRadialColor(fRadius, fIntensity, vPrimaryColor, vSecondaryColor, fOpacity); // used for cloud, firecloud\n"
"    vec4 cloudShellRadialColor = calcCloudShellRadialColor(fRadius, fIntensity, vPrimaryColor, vSecondaryColor, shellOpacity); // used for cloudshell\n"
"    vec4 smokeRadialColor = calcSmokeRadialColor(fRadius, fIntensity, vPrimaryColor, vSecondaryColor, fOpacity); // used for smoke\n"
"//    vec4 fireblastRadialColor = calcFireblastRadialColor(fRadius, fIntensity, vPrimaryColor, vSecondaryColor, fOpacity); // used for smoke\n"
"    vec4 cloudPixelColor = calcCloudPixelColor(fRadius, fIntensity, noise, vPrimaryColor, vSecondaryColor, fOpacity); // used for cloud, cloudshell, smoke\n"
"    vec4 firecloudPixelColor = calcFirecloudPixelColor(fRadius, fIntensity, noise, vPrimaryColor, vSecondaryColor, fOpacity); // used for firecloud\n"
"    vec4 fireblastColor = calcFireblastColor(fRadius, fIntensity, vPrimaryColor, vSecondaryColor, fOpacity); // used for firecloud\n"
"\n"
"    vec4 cloudColor = calcCloudColor(cloudRadialColor, cloudPixelColor);\n"
"    vec4 firecloudColor = calcCloudColor(cloudRadialColor, firecloudPixelColor);\n"
"    vec4 fireCloudshellColor = calcCloudColor(cloudShellRadialColor, firecloudPixelColor);\n"
"    vec4 cloudShellColor = calcCloudColor(cloudShellRadialColor, cloudPixelColor);\n"
"    vec4 smokeColor = calcCloudColor(smokeRadialColor, cloudPixelColor);\n"
"    \n"
"    vec4 smoothColor = calcSmoothColor(fRadius, fIntensity, vPrimaryColor, vSecondaryColor, fOpacity);\n"
"    vec4 blackHoleColor = calcBlackHoleColor(fRadius, fIntensity, vPrimaryColor, vSecondaryColor, fOpacity);\n"
"    vec4 shellColor = calcShellColor(fRadius, fIntensity, vPrimaryColor, vSecondaryColor, shellOpacity);\n"
"    vec4 flareColor = calcFlareColor(fRadius, fIntensity, vPrimaryColor, vSecondaryColor, fOpacity);\n"
"    vec4 diffractionColor = calcDiffractionColor(fRadius, fIntensity, vPrimaryColor, vSecondaryColor, fOpacity, flareColor);\n"
"    \n"
"    vec4 finalColor = (\n"
"        (cloudColor * float(style == styleCloud)) +\n"
"        (firecloudColor * float(style == styleFirecloud)) +\n"
"        (fireCloudshellColor * float(style == styleFireCloudshell)) +\n"
"        (smokeColor * float(style == styleSmoke)) +\n"
"        (smoothColor * float(style == styleSmooth)) +\n"
"        (fireblastColor * float(style == styleFireblast)) +\n"
"        (blackHoleColor * float(style == styleBlackHole)) +\n"
"        (shellColor * float(style == styleShell)) +\n"
"        (flareColor * float(style == styleFlare)) +\n"
"        (diffractionColor * float(style == styleDiffraction)) +\n"
"        (cloudShellColor * float(style == styleCloudshell)) +\n"
"        (flareColor * float(style == styleLightning))\n"
"    );\n"
"    return (finalColor);\n"
"}\n"
"\n"
"float calcAnimateExplodeSecondaryOpacity(float fRadius, float fOpacity, float fFrame) {\n"
"    float fEndFade = float(lifetime) / 3.0;\n"
"    float fEndFadeStart = float(lifetime) - fEndFade;\n"
"    \n"
"    float useEndFadeStart = float(fFrame > fEndFadeStart);\n"
"    float fFadeOpacity = useEndFadeStart * (fEndFade - (fFrame - fEndFadeStart)) / fEndFade;\n"
"    \n"
"    float useOpacity = float(fFrame <= fEndFadeStart);\n"
"    \n"
"    return (fFadeOpacity * useEndFadeStart) + (fOpacity * useOpacity);\n"
"    \n"
"}\n"
"\n"
"vec4 calcAnimationColor(float animatedNoise, float scaledNoise) {\n"
"    // Obtain the following attributes for the sphere color calculation:\n"
"    // m_iStyle, m_iRadius, m_iIntensity, m_rgbPrimaryColor, m_rgbSecondaryColor, m_byOpacity.\n"
"    // Note that style, secondaryColor are not changed by animation style.\n"
"        //CStepIncrementor Opacity(CStepIncrementor::styleSquare, byOpacity, 0.0, iRadius);\n"
"        //FloatIncrementor(fOpacity, 2.0, fRadius, 0.0, pixelsDistanceFromCenter);\n"
"    float fLifetime = float(lifetime);\n"
"    float fCurrframe = float(currFrame);\n"
"    float animateDissipateRadius = FloatIncrementor(0.2 * orbRadius, 0.5, fLifetime, orbRadius, fCurrframe);\n"
"    float animateDissipateIntensity = FloatIncrementor(intensity, 1.0, fLifetime, 0.0, fCurrframe);\n"
"    float animateDissipateDetail = FloatIncrementor(float(detail) / 100.0f, 1.0, fLifetime, float(detail) / 1000.0f, fCurrframe);\n"
"    float animateDissipateColorFade = FloatIncrementor(0.0, 1.0, fLifetime, 1.0, fCurrframe);\n"
"\n"
"    vec3 animateDissipatePrimaryColor = mix(primaryColor, secondaryColor, animateDissipateColorFade);\n"
"    float animateDissipateNoise = scaledNoise;\n"
"    float animateDissipateOpacity = opacityAdj;\n"
"    float animateDissipateSecondaryOpacity = secondaryOpacity;\n"
"\n"
"    float animateExplodeRadius = animateDissipateRadius;\n"
"    float animateExplodeDetail = animateDissipateDetail;\n"
"    float animateExplodeHeat = FloatIncrementor(100.0, 2.0, fLifetime, 0.0, fCurrframe);\n"
"	float animateExplodeIntensity = animateExplodeHeat;\n"
"\n"
"    vec3 animateExplodePrimaryColor = primaryColor;\n"
"    float animateExplodeNoise = scaledNoise;\n"
"    float animateExplodeOpacity = calcAnimateExplodeSecondaryOpacity(orbRadius, opacityAdj, fCurrframe);\n"
"    float animateExplodeSecondaryOpacity = animateExplodeOpacity;\n"
"    \n"
"    float animateFadeProgress = (fLifetime - fCurrframe) / fLifetime;\n"
"    float animateFadeRadius = orbRadius * animateFadeProgress;\n"
"    float animateFadeIntensity = intensity * animateFadeProgress;\n"
"    float animateFadeDetail = animateDissipateDetail;\n"
"\n"
"    vec3 animateFadePrimaryColor = primaryColor;\n"
"    float animateFadeNoise = scaledNoise;\n"
"    float animateFadeOpacity = opacityAdj;\n"
"    float animateFadeSecondaryOpacity = secondaryOpacity;\n"
"    \n"
"    float animateFlickerMultiplier = max(0.5, min(1.0 + (0.25 * cnoise(vec3(0.0, 0.0, current_tick))), 2.0));\n"
"    float animateFlickerRadius = orbRadius * animateFlickerMultiplier;\n"
"    float animateFlickerIntensity = intensity * animateFlickerMultiplier;\n"
"    animateFlickerIntensity = (float(style == styleFireblast) * (min(max(animateFlickerIntensity, 0.0), 100.0))) + (float(style != styleFireblast) * animateFlickerIntensity);\n"
"    vec3 animateFlickerPrimaryColor = primaryColor;\n"
"    float animateFlickerDetail = detail;\n"
"    float animateFlickerNoise = scaledNoise;\n"
"    float animateFlickerOpacity = opacityAdj;\n"
"    float animateFlickerSecondaryOpacity = secondaryOpacity;\n"
"    \n"
"    float animateDimRadius = orbRadius;\n"
"    float animateDimIntensity = intensity;\n"
"    vec3 animateDimPrimaryColor = mix(primaryColor, secondaryColor, FloatIncrementor(0.0, 1.0, fLifetime, 1.0, fCurrframe));\n"
"    float animateDimDetail = detail;\n"
"    float animateDimNoise = scaledNoise;\n"
"    float animateDimOpacity = FloatIncrementor(opacityAdj, 1.0, fLifetime, secondaryOpacity, fCurrframe);\n"
"    float animateDimSecondaryOpacity = secondaryOpacity;\n"
"    \n"
"    float animateNoneRadius = orbRadius;\n"
"    float animateNoneIntensity = intensity;\n"
"    vec3 animateNonePrimaryColor = primaryColor;\n"
"    float animateNoneDetail = detail;\n"
"    float animateNoneNoise = scaledNoise;\n"
"    float animateNoneOpacity = opacityAdj;\n"
"    float animateNoneSecondaryOpacity = secondaryOpacity;\n"
"    \n"
"    float finalRadius = (\n"
"        (animateNoneRadius * float(animation == animateNone)) +\n"
"        (animateDissipateRadius * float(animation == animateDissipate)) +\n"
"        (animateExplodeRadius * float(animation == animateExplode)) +\n"
"        (animateFadeRadius * float(animation == animateFade)) +\n"
"        (animateFlickerRadius * float(animation == animateFlicker)) +\n"
"        (animateDimRadius * float(animation == animateDim))\n"
"    );\n"
"    \n"
"    float finalIntensity = (\n"
"        (animateNoneIntensity * float(animation == animateNone)) +\n"
"        (animateDissipateIntensity * float(animation == animateDissipate)) +\n"
"        (animateExplodeIntensity * float(animation == animateExplode)) +\n"
"        (animateFadeIntensity * float(animation == animateFade)) +\n"
"        (animateFlickerIntensity * float(animation == animateFlicker)) +\n"
"        (animateDimIntensity * float(animation == animateDim))\n"
"    );\n"
"    \n"
"    float finalDetail = (\n"
"        (animateNoneDetail * float(animation == animateNone)) +\n"
"        (animateDissipateDetail * float(animation == animateDissipate)) +\n"
"        (animateExplodeDetail * float(animation == animateExplode)) +\n"
"        (animateFadeDetail * float(animation == animateFade)) +\n"
"        (animateFlickerDetail * float(animation == animateFlicker)) +\n"
"        (animateDimDetail * float(animation == animateDim))\n"
"    );\n"
"    \n"
"    vec3 finalPrimaryColor = (\n"
"        (animateNonePrimaryColor * float(animation == animateNone)) +\n"
"        (animateDissipatePrimaryColor * float(animation == animateDissipate)) +\n"
"        (animateExplodePrimaryColor * float(animation == animateExplode)) +\n"
"        (animateFadePrimaryColor * float(animation == animateFade)) +\n"
"        (animateFlickerPrimaryColor * float(animation == animateFlicker)) +\n"
"        (animateDimPrimaryColor * float(animation == animateDim))\n"
"    );\n"
"    \n"
"    float finalNoise = (\n"
"        (animateNoneNoise * float(animation == animateNone)) +\n"
"        (animateDissipateNoise * float(animation == animateDissipate)) +\n"
"        (animateExplodeNoise * float(animation == animateExplode)) +\n"
"        (animateFadeNoise * float(animation == animateFade)) +\n"
"        (animateFlickerNoise * float(animation == animateFlicker)) +\n"
"        (animateDimNoise * float(animation == animateDim))\n"
"    );\n"
"    \n"
"    float finalOpacity = (\n"
"        (animateNoneOpacity * float(animation == animateNone)) +\n"
"        (animateDissipateOpacity * float(animation == animateDissipate)) +\n"
"        (animateExplodeOpacity * float(animation == animateExplode)) +\n"
"        (animateFadeOpacity * float(animation == animateFade)) +\n"
"        (animateFlickerOpacity * float(animation == animateFlicker)) +\n"
"        (animateDimOpacity * float(animation == animateDim))\n"
"    );\n"
"    \n"
"    float finalSecondaryOpacity = (\n"
"        (animateNoneSecondaryOpacity * float(animation == animateNone)) +\n"
"        (animateDissipateSecondaryOpacity * float(animation == animateDissipate)) +\n"
"        (animateExplodeSecondaryOpacity * float(animation == animateExplode)) +\n"
"        (animateFadeSecondaryOpacity * float(animation == animateFade)) +\n"
"        (animateFlickerSecondaryOpacity * float(animation == animateFlicker)) +\n"
"        (animateDimSecondaryOpacity * float(animation == animateDim))\n"
"    );\n"
"    \n"
"//    return vec4(0.5);\n"
"    // We only use secondary color table for fireblast.\n"
"    return calcPrimaryColor(style, finalRadius, finalIntensity, finalPrimaryColor, secondaryColor, finalOpacity, scaledNoise);\n"
"}\n"
"\n"
"void main(void)\n"
"{\n"
"    // Calculate the animation and style intermediates.\n"
"    // Really, the style is just what kind of texture we use (fireblast, diffraction or cloud).\n"
"    // For fireblast/cloud the fractal pattern can be done with Perlin noise FBM technique.\n"
"    float animatedNoise = fbm(quadPos, current_tick) + 0.5;\n"
"    float scaledNoise = fbm(quadPos / (orbRadius / 200), current_tick) + 0.5;\n"
"    //fragColor = vec4(rand(vec2(pixelsDistanceFromCenter)));\n"
"	\n"
"	vec4 finalColor = calcAnimationColor(animatedNoise, scaledNoise);\n"
"	bool alphaIsZero = finalColor[3] < 0.01;\n"
"	gl_FragDepth = depth + float(alphaIsZero);\n"
"    fragColor = finalColor;\n"
"    //fragColor = vec4(0.2);\n"
"    //fragColor = vec4(fbm(quadPos* 1.0, current_tick) + 0.5);\n"
"}\n";
const std::string FPerlinNoiseShader =
"#version 400\n"
"\n"
"uniform float time;\n"
"\n"
"in vec2 TexCoord;\n"
"\n"
"float rand(vec2 co){\n"
"  // Canonical PRNG from https://stackoverflow.com/questions/12964279/whats-the-origin-of-this-glsl-rand-one-liner\n"
"  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n"
"}\n"
"\n"
"//  Classic Perlin 3D Noise \n"
"//  by Stefan Gustavson\n"
"//\n"
"//  Found at https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n"
"vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\n"
"vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n"
"vec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n"
"\n"
"float cnoise(vec3 P){\n"
"  vec3 Pi0 = floor(P); // Integer part for indexing\n"
"  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n"
"  Pi0 = mod(Pi0, 289.0);\n"
"  Pi1 = mod(Pi1, 289.0);\n"
"  vec3 Pf0 = fract(P); // Fractional part for interpolation\n"
"  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n"
"  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n"
"  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n"
"  vec4 iz0 = Pi0.zzzz;\n"
"  vec4 iz1 = Pi1.zzzz;\n"
"\n"
"  vec4 ixy = permute(permute(ix) + iy);\n"
"  vec4 ixy0 = permute(ixy + iz0);\n"
"  vec4 ixy1 = permute(ixy + iz1);\n"
"\n"
"  vec4 gx0 = ixy0 / 7.0;\n"
"  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n"
"  gx0 = fract(gx0);\n"
"  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n"
"  vec4 sz0 = step(gz0, vec4(0.0));\n"
"  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n"
"  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n"
"\n"
"  vec4 gx1 = ixy1 / 7.0;\n"
"  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n"
"  gx1 = fract(gx1);\n"
"  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n"
"  vec4 sz1 = step(gz1, vec4(0.0));\n"
"  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n"
"  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n"
"\n"
"  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n"
"  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n"
"  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n"
"  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n"
"  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n"
"  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n"
"  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n"
"  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n"
"\n"
"  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n"
"  g000 *= norm0.x;\n"
"  g010 *= norm0.y;\n"
"  g100 *= norm0.z;\n"
"  g110 *= norm0.w;\n"
"  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n"
"  g001 *= norm1.x;\n"
"  g011 *= norm1.y;\n"
"  g101 *= norm1.z;\n"
"  g111 *= norm1.w;\n"
"\n"
"  float n000 = dot(g000, Pf0);\n"
"  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n"
"  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n"
"  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n"
"  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n"
"  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n"
"  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n"
"  float n111 = dot(g111, Pf1);\n"
"\n"
"  vec3 fade_xyz = fade(Pf0);\n"
"  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n"
"  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n"
"  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n"
"  return 2.2 * n_xyz;\n"
"}\n"
"\n"
"\n"
"float fbm(vec2 p, float time, float amp)\n"
"{\n"
"    // Fractal Brownian Motion using Perlin noise\n"
"     float v = 0.0;\n"
"     float freq = 20;\n"
"     float phase_shift = 2.0;\n"
"     int octaves = 10;\n"
"     for (int i = 0; i < octaves; i++)\n"
"         v += cnoise(vec3(((p + vec2(1000.0, 1000.0)) * (i * freq)), (time * (float(i) * phase_shift)) / 1000)) * (amp / (i + 1));\n"
"\n"
"     return v;\n"
"}\n"
"\n"
"float fbm_animated(vec2 p, float time)\n"
"{\n"
"    // Fractal Brownian Motion using Perlin noise\n"
"     float v = 1.0;\n"
"     int octaves = 5;\n"
"     for (int i = 0; i < octaves; i++) {\n"
"         int rseed = i + 123;\n"
"         vec2 rand_dir = normalize(vec2(rand(vec2(rseed, rseed)), rand(vec2(rseed+1, rseed+1)))) * 0.005;\n"
"         v *= ((fbm(vec2((p * 5 * (rand(vec2(rseed+2, rseed-2)) - 0.5)) + time*rand_dir), 0.0, 1.0) + 1) * 0.5) * 2.0;\n"
"     }\n"
"\n"
"     return v / 4.0;\n"
"}\n"
"\n"
"float fbm_lightning(vec2 p, float time)\n"
"{\n"
"     float v = 0.0;\n"
"     float amp = 0.75;\n"
"     float freq = 1;\n"
"     int octaves = 2;\n"
"     for (int i = 0; i < octaves; i++)\n"
"         v += cnoise(vec3((p * (i * freq)), time)) * (amp / (i + 1));\n"
"\n"
"     return v;\n"
"}\n"
"\n"
"out vec4 fragColor;\n"
"\n"
"void main(void)\n"
"{\n"
"    vec2 uv = -1. + 2. * TexCoord;\n"
"	float fbm_tex = (fbm(uv, time * 50, 0.5) + 1.0) / 2.0;\n"
"	float fbm_animated = (fbm_animated(uv, time) + 1.0) / 2.0;\n"
"	float raw_perlin = (cnoise(vec3(uv.x * 20, uv.y * 20, time * 1)) * 0.5) + 0.5;\n"
"    fragColor = vec4(fbm_tex, raw_perlin, fbm_animated, 1.0);\n"
"}\n";

const std::string FCanvasShader =
"#version 410 core\n"
"out vec4 FragColor;\n"
"  \n"
"in vec3 ourColor;\n"
"in vec2 TexCoord;\n"
"\n"
"uniform float depth;\n"
"uniform sampler2D ourTexture;\n"
"\n"
"float roundme(float input_float)\n"
"{\n"
"    float roundLevels = 5.0f;\n"
"    return float(round(input_float * roundLevels)) / roundLevels;\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	vec2 onePixel = vec2(1.0, 1.0) / textureSize(ourTexture, 0);\n"
"    vec4 RealColor = texture(ourTexture, vec2(-TexCoord[0], TexCoord[1]));\n"
"	gl_FragDepth = depth;\n"
"	FragColor = RealColor;\n"
"	//FragColor = vec4(roundme(RealColor[0]), roundme(RealColor[1]), roundme(RealColor[2]), roundme(RealColor[3]));\n"
"}\n";
